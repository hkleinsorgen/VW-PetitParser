<?xml version="1.0"?>

<st-source>
<!-- 
Name: PetitParser
Notice: PetitParser is licensed under the MIT license.
Comment: A port of the PetitParser

http://source.lukas-renggli.ch/petit.html
http://scg.unibe.ch/research/helvetia/petitparser

PetitParser is licensed under the MIT license.
DevelopmentPrerequisites: #(#(#any 'PetitParser-Preload' ''))
Id: 4d5e3605-34bf-4bae-b552-60d1ae1087de
KSignature: #('definedClasses' 33 'definedClassesHash' 20894619431 'extendedClasses' 13 'extendedClassesHash' 2268824563)
KSignatureV2: #('definedClasses' 33 'definedClassesHash' 482393689071017397636335811948604637209279557750 'extendedClasses' 13 'extendedClassesHash' 1077479697437135668130874851075071970843589046014)
Namespace: PetitParser
PackageName: PetitParser
Parcel: #('PetitParser')
ParcelDirectory: e:\develop\git\jse\PetitParser
ParcelName: PetitParser
PrerequisiteDescriptions: #(#(#name 'PetitParser-Preload'))
PrerequisiteParcels: #(#('PetitParser-Preload' ''))
TestCoverage: false
Url: http://source.lukas-renggli.ch/petit/PetitParser-lr.202.mcz
Date: 2:16:08 PM September 16, 2017
 -->
<time-stamp>From VisualWorks®, 8.1.1 of 10. März 2016 on 16. September 2017 at 14:16:08</time-stamp>


<do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it>

<class>
<name>PPParser</name>
<environment>PetitParser</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>properties </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPParser</class-id>
<body>An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	&lt;Dictionary&gt;	Stores additional state in the parser object.</body>
</comment>

<class>
<name>PPDelegateParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>parser </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPDelegateParser</class-id>
<body>A parser that delegates to another parser.Instance Variables:	parser	&lt;PPParser&gt;	The parser to delegate to.</body>
</comment>

<class>
<name>PPNotParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPNotParser</class-id>
<body>The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].</body>
</comment>

<class>
<name>PPActionParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>block </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPActionParser</class-id>
<body>A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	&lt;BlockClosure&gt;	The action block to be executed.</body>
</comment>

<class>
<name>PPTrimmingParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>trimmer </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPTrimmingParser</class-id>
<body>A parser that silently consumes spaces before and after the delegate parser.</body>
</comment>

<class>
<name>PPListParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>parsers </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPListParser</class-id>
<body>Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	&lt;SequenceableCollection of: PPParser&gt;	A sequence of other parsers to delegate to.</body>
</comment>

<class>
<name>PPSequenceParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPListParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPSequenceParser</class-id>
<body>A parser that parses a sequence of parsers.</body>
</comment>

<class>
<name>PPPredicateParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>predicate predicateMessage negated negatedMessage </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPPredicateParser</class-id>
<body>An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	&lt;BlockClosure&gt;	The block testing for the predicate.	predicateMessage	&lt;String&gt;	The error message of the predicate.	negated	&lt;BlockClosure&gt;	The block testing for the negation of the predicate.	negatedMessage	&lt;String&gt;	The error message of the negated predicate.</body>
</comment>

<class>
<name>PPPredicateSequenceParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPPredicateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>size </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPPredicateSequenceParser</class-id>
<body>A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	&lt;Integer&gt;	The number of elements to consume.</body>
</comment>

<class>
<name>PPCompositeParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Tools</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPCompositeParser</class-id>
<body>A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.</body>
</comment>

<class>
<name>PPFlattenParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPFlattenParser</class-id>
<body>A parser that answers a flat copy of the range my delegate parses.</body>
</comment>

<class>
<name>PPLiteralParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>literal message </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPLiteralParser</class-id>
<body>Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	&lt;Object&gt;	The literal object to be parsed.	message	&lt;String&gt;	The error message to be generated.</body>
</comment>

<class>
<name>PPLiteralSequenceParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPLiteralParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>size </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPLiteralSequenceParser</class-id>
<body>A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.</body>
</comment>

<class>
<name>PPChoiceParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPListParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPChoiceParser</class-id>
<body>A parser that uses the first parser that succeeds.</body>
</comment>

<class>
<name>PPLiteralObjectParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPLiteralParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPLiteralObjectParser</class-id>
<body>A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.</body>
</comment>

<class>
<name>PPMemoizedParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>stream buffer </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPMemoizedParser</class-id>
<body>A memoized parser, for refraining redundant computations.Instance Variables:	stream	&lt;PositionableStream&gt;	The stream of the associated memento objects.	buffer	&lt;Array of: PPMemento&gt;	The buffer of memento objects.</body>
</comment>

<class>
<name>PPRepeatingParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>min max </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPRepeatingParser</class-id>
<body>A parser that eagerly parses min to max instances of my delegate. The default instance parses eagerly an infinite number of elements, as min is set to 0 and max to infinity (SmallInteger maxVal).Instance Variables:	min	&lt;Integer&gt;	The minimum number of repetitions.	max	&lt;Integer&gt;	The maximum number of repetitions.</body>
</comment>

<class>
<name>PPEndOfInputParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPEndOfInputParser</class-id>
<body>A parser that succeeds only at the end of the input stream.</body>
</comment>

<class>
<name>PPAndParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPAndParser</class-id>
<body>The and-predicate, a parser that succeeds whenever its delegate does, but consumes the input stream [Parr 1994, 1995].</body>
</comment>

<class>
<name>PPExpressionParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>operators </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Tools</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPExpressionParser</class-id>
<body>A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==&gt; [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==&gt; [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	&lt;Dictionary&gt;	The operators defined in the current group.</body>
</comment>

<class>
<name>PPCharSetPredicate</name>
<environment>PetitParser</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>block classification </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Tools</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<class>
<name>PPPredicateObjectParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPPredicateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPPredicateObjectParser</class-id>
<body>A parser that accepts if a given predicate on one element of the input sequence holds.</body>
</comment>

<class>
<name>PPWrappingParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPActionParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPWrappingParser</class-id>
<body>A parser that performs an action block upon activation with the stream and a continuation block.</body>
</comment>

<class>
<name>PPStream</name>
<environment>PetitParser</environment>
<super>Core.ReadStream</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>furthestFailure </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Core</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPStream</class-id>
<body>A positional stream implementation used for parsing. It overrides some methods for optimization reasons.</body>
</comment>

<class>
<name>PPTokenParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPFlattenParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>tokenClass </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPTokenParser</class-id>
<body>A parser that answers a token of the range my delegate parses.Instance Variables:	tokenClass	&lt;PPToken class&gt;	The token sub-class to be used.</body>
</comment>

<class>
<name>PPToken</name>
<environment>PetitParser</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>collection start stop </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Core</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPToken</class-id>
<body>PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection and its start and stop position.Instance Variables:	collection	&lt;SequenceableCollection&gt;	The collection this token comes from.	start	&lt;Integer&gt;	The start position in the collection.	stop	&lt;Integer&gt;	The stop position in the collection.</body>
</comment>

<class>
<name>PPMemento</name>
<environment>PetitParser</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>result count position </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Core</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPMemento</class-id>
<body>PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	&lt;Object&gt;	The cached result.	count	&lt;Integer&gt;	The number of recursive cycles followed.	position	&lt;Integer&gt;	The position of the cached result in the input stream.</body>
</comment>

<class>
<name>PPFailure</name>
<environment>PetitParser</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>message position </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Core</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPFailure</class-id>
<body>The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	&lt;String&gt;	The error message of this failure.	position	&lt;Integer&gt;	The position of this failure in the input stream.</body>
</comment>

<class>
<name>PPPluggableParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>block </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPPluggableParser</class-id>
<body>A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	&lt;BlockClosure&gt;	The pluggable one-argument block.</body>
</comment>

<class>
<name>PPFailingParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>message </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPFailingParser</class-id>
<body>A parser that consumes nothing and always fails.Instance Variables:	message &lt;String&gt;	The failure message.</body>
</comment>

<class>
<name>PPEpsilonParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPEpsilonParser</class-id>
<body>A parser that consumes nothing and always succeeds.</body>
</comment>

<class>
<name>PPUnresolvedParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Tools</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPUnresolvedParser</class-id>
<body>This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.</body>
</comment>

<class>
<name>PPOptionalParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Parsers</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<methods>
<class-id>Core.Object</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPPredicateObjectParser expect: self</body>
</methods>

<methods>
<class-id>Core.Object</class-id> <category>*petitparser-core-testing</category>

<body package="PetitParser">isPetitFailure	^ false</body>

<body package="PetitParser">isPetitParser	^ false</body>
</methods>

<methods>
<class-id>Core.String</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPLiteralSequenceParser on: self</body>
</methods>

<methods>
<class-id>Core.Character</class-id> <category>*petitparser-core-operators</category>

<body package="PetitParser">- aCharacter	"Create a range of characters between the receiver and the argument."		^ PPPredicateObjectParser between: self and: aCharacter</body>
</methods>

<methods>
<class-id>Core.Character</class-id> <category>*petitparser-converting</category>

<body package="PetitParser">asParser	^ PPLiteralObjectParser on: self</body>
</methods>

<methods>
<class-id>Core.Symbol</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPPredicateObjectParser perform: self</body>
</methods>

<methods>
<class-id>OS.BufferedExternalStream</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asPetitStream	^ self</body>
</methods>

<methods>
<class-id>Core.SequenceableCollection</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])</body>

<body package="PetitParser">asPetitStream	^ PPStream on: self</body>
</methods>

<methods>
<class-id>Core.SequenceableCollection</class-id> <category>copying</category>

<body package="PetitParser">petitCopyWithFirst: anObject	^ (self class new: self size + 1)		replaceFrom: 2 to: self size + 1 with: self;		at: 1 put: anObject;		yourself</body>
</methods>

<methods>
<class-id>Core.SequenceableCollection</class-id> <category>accessing</category>

<body package="PetitParser">petitSecond	^ self at: 2</body>

<body package="PetitParser">petitThird	^ self at: 3</body>
</methods>

<methods>
<class-id>Core.Set</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])</body>
</methods>

<methods>
<class-id>Kernel.BlockContext</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPPluggableParser on: self</body>
</methods>

<methods>
<class-id>Core.UndefinedObject</class-id> <category>*petitparser-converting</category>

<body package="PetitParser">asParser	^ PPEpsilonParser new</body>
</methods>

<methods>
<class-id>Kernel.BlockClosure</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asParser	^ PPPluggableParser on: self</body>
</methods>

<methods>
<class-id>Core.Text</class-id> <category>*petitparser-core</category>

<body package="PetitParser">asPetitStream	^ string asPetitStream</body>
</methods>

<methods>
<class-id>Core.PositionableStream</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asPetitStream	"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases."	^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])		ifFalse: [ PPStream on: collection from: position to: readLimit ]		ifTrue: [ super asPetitStream ]</body>
</methods>

<methods>
<class-id>Core.Stream</class-id> <category>*petitparser-core-converting</category>

<body package="PetitParser">asPetitStream	^ self contents asPetitStream</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>operations</category>

<body package="PetitParser">, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser</body>

<body package="PetitParser">/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser</body>

<body package="PetitParser">and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self</body>

<body package="PetitParser">def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)</body>

<body package="PetitParser">end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self</body>

<body package="PetitParser">max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ PPRepeatingParser on: self max: anInteger</body>

<body package="PetitParser">memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self</body>

<body package="PetitParser">min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ PPRepeatingParser on: self min: anInteger</body>

<body package="PetitParser">min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ PPRepeatingParser on: self min: aMinInteger max: aMaxInteger</body>

<body package="PetitParser">negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser ==&gt; #petitSecond</body>

<body package="PetitParser">not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self</body>

<body package="PetitParser">optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self</body>

<body package="PetitParser">plus	"Answer a new parser that parses the receiver one or more times."	^ self min: 1</body>

<body package="PetitParser">plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ self , (self starGreedy: aParser) map: [ :first :rest | rest petitCopyWithFirst: first ]</body>

<body package="PetitParser">plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ self , (self starLazy: aParser) map: [ :first :rest | rest petitCopyWithFirst: first ]</body>

<body package="PetitParser">star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPRepeatingParser on: self</body>

<body package="PetitParser">starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (aParser and ==&gt; [ :each | OrderedCollection new ])).	^ parser ==&gt; [ :rest | rest asArray ]</body>

<body package="PetitParser">starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (aParser and ==&gt; [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==&gt; [ :rest | rest asArray ]</body>

<body package="PetitParser">times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger</body>

<body package="PetitParser">wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self</body>

<body package="PetitParser">| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==&gt; #petitSecond</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>accessing-properties</category>

<body package="PetitParser">hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]</body>

<body package="PetitParser">propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]</body>

<body package="PetitParser">propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]</body>

<body package="PetitParser">propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]</body>

<body package="PetitParser">propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject</body>

<body package="PetitParser">removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]</body>

<body package="PetitParser">removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>printing</category>

<body package="PetitParser">printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]</body>

<body package="PetitParser">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>operations-mapping</category>

<body package="PetitParser">==&gt; aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock</body>

<body package="PetitParser">&gt;=&gt; aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock</body>

<body package="PetitParser">answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self ==&gt; [ :nodes | anObject ]</body>

<body package="PetitParser">flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self</body>

<body package="PetitParser">foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==&gt; [ :nodes |		args at: 1 put: (nodes at: 1).		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args at: 1 ]</body>

<body package="PetitParser">foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==&gt; [ :nodes |		args at: size put: (nodes at: nodes size).		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]</body>

<body package="PetitParser">map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ self ==&gt; aBlock</body>

<body package="PetitParser">token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self</body>

<body package="PetitParser">token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass</body>

<body package="PetitParser">trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces</body>

<body package="PetitParser">trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: #blank asParser</body>

<body package="PetitParser">trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: #space asParser</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>parsing</category>

<body package="PetitParser">matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not</body>

<body package="PetitParser">matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result</body>

<body package="PetitParser">matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	((self and ==&gt; aBlock , #any asParser) / #any asParser) star parse: anObject</body>

<body package="PetitParser">matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver.  Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	[ :stream | stream position + 1 ] asParser , self , [ :stream | stream position ] asParser		matchesIn: anObject		do: [ :value | result addLast: (value first to: value last) ].	^ result</body>

<body package="PetitParser">parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."		^ self parseOn: anObject asPetitStream</body>

<body package="PetitParser">parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parseOn: anObject asPetitStream.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position</body>

<body package="PetitParser">parseOn: aStream	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>testing</category>

<body package="PetitParser">isPetitParser	^ true</body>

<body package="PetitParser">isUnresolved	^ false</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>copying</category>

<body package="PetitParser">postCopy	super postCopy.	properties := properties copy</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>initialization</category>

<body package="PetitParser">initialize</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>accessing</category>

<body package="PetitParser">children	"Answer a set of child parsers that could follow the receiver."	^ #()</body>

<body package="PetitParser">name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]</body>

<body package="PetitParser">name: aString	self propertyAt: #name put: aString</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>private</category>

<body package="PetitParser">becomeForward: anObject	^ self oneWayBecome: anObject</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>converting</category>

<body package="PetitParser">asParser	^ self</body>
</methods>

<methods>
<class-id>PetitParser.PPParser</class-id> <category>operations-convenience</category>

<body package="PetitParser">delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==&gt; [ :node |		node petitSecond isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node petitSecond ] ]</body>

<body package="PetitParser">separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) ==&gt; [ :nodes |		| result |		result := Array new: 2 * nodes petitSecond size + 1.		result at: 1 put: nodes first.		nodes petitSecond 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]</body>
</methods>

<methods>
<class-id>PetitParser.PPParser class</class-id> <category>instance creation</category>

<body package="PetitParser">named: aString	^ self new name: aString</body>

<body package="PetitParser">new	^ self basicNew initialize</body>
</methods>

<methods>
<class-id>PetitParser.PPDelegateParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	^ parser parseOn: aStream</body>
</methods>

<methods>
<class-id>PetitParser.PPDelegateParser</class-id> <category>initialization</category>

<body package="PetitParser">setParser: aParser	parser := aParser</body>
</methods>

<methods>
<class-id>PetitParser.PPDelegateParser</class-id> <category>accessing</category>

<body package="PetitParser">children	^ Array with: parser</body>
</methods>

<methods>
<class-id>PetitParser.PPDelegateParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aParser	^ self new setParser: aParser</body>
</methods>

<methods>
<class-id>PetitParser.PPNotParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element isPetitFailure 		ifTrue: [ nil ]		ifFalse: [ PPFailure message: '' stream: aStream ]</body>
</methods>

<methods>
<class-id>PetitParser.PPActionParser</class-id> <category>accessing</category>

<body package="PetitParser">block	"Answer the action block of the receiver."	^ block</body>
</methods>

<methods>
<class-id>PetitParser.PPActionParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	| element |	^ (element := parser parseOn: aStream) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]</body>
</methods>

<methods>
<class-id>PetitParser.PPActionParser</class-id> <category>initialization</category>

<body package="PetitParser">setBlock: aBlock	block := aBlock</body>
</methods>

<methods>
<class-id>PetitParser.PPActionParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock</body>
</methods>

<methods>
<class-id>PetitParser.PPTrimmingParser</class-id> <category>operations</category>

<body package="PetitParser">trim	"There is no point in trimming more than once."	^ self</body>
</methods>

<methods>
<class-id>PetitParser.PPTrimmingParser</class-id> <category>initialization</category>

<body package="PetitParser">setTrimmer: aParser	trimmer := aParser</body>
</methods>

<methods>
<class-id>PetitParser.PPTrimmingParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| position element |	position := aStream position.	[( trimmer parseOn: aStream ) isPetitFailure ] whileFalse.	element := parser parseOn: aStream.	element isPetitFailure 		ifTrue: 		[	aStream position: position.			^ element		].	[( trimmer parseOn: aStream ) isPetitFailure ] whileFalse.	^ element</body>
</methods>

<methods>
<class-id>PetitParser.PPTrimmingParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself</body>
</methods>

<methods>
<class-id>PetitParser.PPListParser</class-id> <category>accessing</category>

<body package="PetitParser">children	^ parsers</body>
</methods>

<methods>
<class-id>PetitParser.PPListParser</class-id> <category>copying</category>

<body package="PetitParser">copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)</body>

<body package="PetitParser">postCopy	super postCopy.	parsers := parsers copy</body>
</methods>

<methods>
<class-id>PetitParser.PPListParser</class-id> <category>initialization</category>

<body package="PetitParser">initialize	super initialize.	self setParsers: #()</body>

<body package="PetitParser">setParsers: aCollection	parsers := aCollection asArray</body>
</methods>

<methods>
<class-id>PetitParser.PPListParser class</class-id> <category>instance creation</category>

<body package="PetitParser">with: aParser	^ self withAll: (Array with: aParser)</body>

<body package="PetitParser">with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)</body>

<body package="PetitParser">withAll: aCollection	^ self basicNew setParsers: aCollection</body>
</methods>

<methods>
<class-id>PetitParser.PPSequenceParser</class-id> <category>operations</category>

<body package="PetitParser">, aRule	^ self copyWith: aRule</body>

<body package="PetitParser">map: aBlock	^ self ==&gt; [ :nodes | aBlock valueWithArguments: nodes ]</body>

<body package="PetitParser">permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self ==&gt; [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]</body>
</methods>

<methods>
<class-id>PetitParser.PPSequenceParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	"This is optimized code that avoids unnecessary block activations, do not change."	| start elements element |	start := aStream position.	elements := Array new: parsers size.	1 to: parsers size		do: 		[: index |			element := ( parsers at: index ) parseOn: aStream.			element isPetitFailure 				ifTrue: 				[	aStream position: start.					^ element				].			elements at: index put: element		].	^ elements</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateParser</class-id> <category>accessing</category>

<body package="PetitParser">block	"Answer the predicate block of the receiver."		^ predicate</body>

<body package="PetitParser">message	"Answer the failure message."		^ predicateMessage</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateParser</class-id> <category>printing</category>

<body package="PetitParser">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>operators</category>

<body package="PetitParser">negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>accessing</category>

<body package="PetitParser">size	"Answer the sequence size of the receiver."	^ size</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| position result |	position := aStream position.	result := aStream next: size.	( result size = size and: [ predicate value: result ]) 		ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: predicateMessage stream: aStream</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateSequenceParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger</body>

<body package="PetitParser">on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParser</class-id> <category>querying</category>

<body package="PetitParser">productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]</body>

<body package="PetitParser">productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ parser ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParser</class-id> <category>initialization</category>

<body package="PetitParser">initializeStartingAt: aSymbol	| allVariableNames ignoredVariableNames productionIndexesAndNames |	self initialize.		"find all the productions that need to be initialized"	allVariableNames := self class allInstVarNames		collect: [ :each | each asSymbol ].	ignoredVariableNames := self class ignoredNames		collect: [ :each | each asSymbol ].	productionIndexesAndNames := ((1 to: self class instSize)		collect: [ :index | index -&gt; (allVariableNames at: index) ])		reject: [ :assoc | ignoredVariableNames includes: assoc value ].		"initialize productions with an undefined parser to be replaced later"	parser := PPUnresolvedParser named: aSymbol.	productionIndexesAndNames do: [ :assoc |		self instVarAt: assoc key put: (PPUnresolvedParser named: assoc value) ].	parser def: (self perform: aSymbol).		"resolve unresolved parsers with their actual implementation"	productionIndexesAndNames do: [ :assoc |		(self respondsTo: assoc value)			ifFalse: [ self error: 'Unable to initialize ' , assoc value printString ]			ifTrue: [ (self instVarAt: assoc key) def: (self perform: assoc value) ] ]</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParser</class-id> <category>accessing</category>

<body package="PetitParser">start	"Answer the production to start this parser with."		self subclassResponsibility</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParser class</class-id> <category>parsing</category>

<body package="PetitParser">parse: anObject	^ self parse: anObject startingAt: self startSymbol</body>

<body package="PetitParser">parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock</body>

<body package="PetitParser">parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject</body>

<body package="PetitParser">parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParser class</class-id> <category>instance creation</category>

<body package="PetitParser">new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol</body>

<body package="PetitParser">newStartingAt: aSymbol	"Answer a new parser starting at aSymbol."	^ self basicNew initializeStartingAt: aSymbol</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParser class</class-id> <category>accessing</category>

<body package="PetitParser">ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PPCompositeParser allInstVarNames</body>

<body package="PetitParser">startSymbol	"Answer the method that represents the default start symbol."	^ #start</body>
</methods>

<methods>
<class-id>PetitParser.PPFlattenParser</class-id> <category>hooks</category>

<body package="PetitParser">create: aCollection start: aStartInteger stop: aStopInteger	^ aCollection copyFrom: aStartInteger to: aStopInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPFlattenParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	| start element stop |	start := aStream position.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [		aStream position: start.		^ element ].	stop := aStream position.	^ self create: aStream collection start: start + 1 stop: stop</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralParser</class-id> <category>operators</category>

<body package="PetitParser">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralParser</class-id> <category>accessing</category>

<body package="PetitParser">literal	"Answer the parsed literal."	^ literal</body>

<body package="PetitParser">message	"Answer the failure message."		^ message</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralParser</class-id> <category>printing</category>

<body package="PetitParser">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralParser</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: anObject message: aString	literal := anObject.	message := aString</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: anObject	^ self on: anObject message: anObject printString , ' expected'</body>

<body package="PetitParser">on: anObject message: aString	^ self new initializeOn: anObject message: aString</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>operators</category>

<body package="PetitParser">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>accessing</category>

<body package="PetitParser">size	"Answer the sequence size of the receiver."	^ size</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| position result |	position := aStream position.	result := aStream next: size.	result = literal 		ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: message stream: aStream</body>
</methods>

<methods>
<class-id>PetitParser.PPChoiceParser</class-id> <category>operations</category>

<body package="PetitParser">/ aRule 	^ self copyWith: aRule</body>
</methods>

<methods>
<class-id>PetitParser.PPChoiceParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	"This is optimized code that avoids unnecessary block activations, do not change. 	When all choices fail, the failure of the longest branch is answered."	| element furthestFailure |	furthestFailure := nil.	1 to: parsers size		do: 		[: index |			element := ( parsers at: index ) parseOn: aStream.			element isPetitFailure 				ifFalse: [ ^ element ].			( furthestFailure isNil or: [ element position &gt; furthestFailure position ]) 				ifTrue: [ furthestFailure := element ]		].	^ furthestFailure</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralObjectParser</class-id> <category>operators</category>

<body package="PetitParser">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message</body>
</methods>

<methods>
<class-id>PetitParser.PPLiteralObjectParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	^ ( aStream atEnd not and: [ aStream peek = literal ]) 		ifFalse: [ PPFailure message: message stream: aStream ]		ifTrue: [ aStream next ]</body>
</methods>

<methods>
<class-id>PetitParser.PPMemoizedParser</class-id> <category>operations</category>

<body package="PetitParser">memoized	"Ther is no point in memoizing more than once."	^ self</body>
</methods>

<methods>
<class-id>PetitParser.PPMemoizedParser</class-id> <category>private</category>

<body package="PetitParser">reset: aStream	stream := aStream.	buffer := Array new: aStream size + 1</body>
</methods>

<methods>
<class-id>PetitParser.PPMemoizedParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| memento |	stream == aStream 		ifFalse: [ self reset: aStream ].	memento := ( buffer at: stream position + 1 ) ifNil: [ buffer at: stream position + 1 put: PPMemento new ].	memento position isNil 		ifTrue: 		[	memento result: ( stream size - stream position + 2 &lt; memento count 						ifTrue: [ PPFailure message: 'overflow' stream: stream ]						ifFalse: 						[	memento increment.							parser parseOn: stream						]).			memento position: stream position		]		ifFalse: [ stream position: memento position ].	^ memento result</body>
</methods>

<methods>
<class-id>PetitParser.PPRepeatingParser</class-id> <category>printing</category>

<body package="PetitParser">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]</body>
</methods>

<methods>
<class-id>PetitParser.PPRepeatingParser</class-id> <category>accessing</category>

<body package="PetitParser">max	"Answer the maximum number of repetitions."	^ max</body>

<body package="PetitParser">min	"Answer the minimum number of repetitions."		^ min</body>
</methods>

<methods>
<class-id>PetitParser.PPRepeatingParser</class-id> <category>initialization</category>

<body package="PetitParser">setMin: aMinInteger max: aMaxInteger	min := aMinInteger.	max := aMaxInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPRepeatingParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: 		[	( element := parser parseOn: aStream ) isPetitFailure 				ifTrue: 				[	aStream position: start.					^ element				].			elements addLast: element		].	[ elements size &lt; max ] whileTrue: 		[	( element := parser parseOn: aStream ) isPetitFailure 				ifTrue: [ ^ elements asArray ].			elements addLast: element		].	^ elements asArray</body>
</methods>

<methods>
<class-id>PetitParser.PPRepeatingParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aParser	^ (super on: aParser) setMin: 0 max: SmallInteger maxVal</body>

<body package="PetitParser">on: aParser max: aMaxInteger	^ (self on: aParser) setMin: 0 max: aMaxInteger</body>

<body package="PetitParser">on: aParser min: aMinInteger	^ (self on: aParser) setMin: aMinInteger max: SmallInteger maxVal</body>

<body package="PetitParser">on: aParser min: aMinInteger max: aMaxInteger	^ (self on: aParser) setMin: aMinInteger max: aMaxInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPEndOfInputParser</class-id> <category>operations</category>

<body package="PetitParser">end	^ self</body>
</methods>

<methods>
<class-id>PetitParser.PPEndOfInputParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| position result |	position := aStream position.	result := parser parseOn: aStream.	( result isPetitFailure or: [ aStream atEnd ]) 		ifTrue: [ ^ result ].	result := PPFailure message: 'end of input expected' stream: aStream.	aStream position: position.	^ result</body>
</methods>

<methods>
<class-id>PetitParser.PPAndParser</class-id> <category>operations</category>

<body package="PetitParser">and	^ self</body>
</methods>

<methods>
<class-id>PetitParser.PPAndParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element</body>
</methods>

<methods>
<class-id>PetitParser.PPExpressionParser</class-id> <category>specifying</category>

<body package="PetitParser">group: aOneArgumentBlock	"Defines a priority group by evaluating aOneArgumentBlock."		operators := Dictionary new.	parser := [ 		aOneArgumentBlock value: self.	 	self buildOn: parser ]			ensure: [ operators := nil ]</body>

<body package="PetitParser">left: aParser do: aThreeArgumentBlock	"Define an operator aParser that is left-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:left: parser: aParser do: aThreeArgumentBlock</body>

<body package="PetitParser">postfix: aParser do: aTwoArgumentBlock	"Define a postfix operator aParser. Evaluate aTwoArgumentBlock with the term and the operator."	self operator: #build:postfix: parser: aParser do: aTwoArgumentBlock</body>

<body package="PetitParser">prefix: aParser do: aTwoArgumentBlock	"Define a prefix operator aParser. Evaluate aTwoArgumentBlock with the operator and the term."	self operator: #build:prefix: parser: aParser do: aTwoArgumentBlock</body>

<body package="PetitParser">right: aParser do: aThreeArgumentBlock	"Define an operator aParser that is right-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:right: parser: aParser do: aThreeArgumentBlock</body>

<body package="PetitParser">term: aParser	"Defines the initial term aParser of the receiver."		parser isNil		ifTrue: [ parser := aParser ]		ifFalse: [ self error: 'Unable to redefine the term.' ]</body>
</methods>

<methods>
<class-id>PetitParser.PPExpressionParser</class-id> <category>private</category>

<body package="PetitParser">build: aParser left: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldLeft: [ :a :op :b | op first value: a value: op petitSecond value: b ]</body>

<body package="PetitParser">build: aParser postfix: aChoiceParser	^ aParser , aChoiceParser star map: [ :term :ops | ops inject: term into: [ :result :operator | operator first value: result value: operator petitSecond ] ]</body>

<body package="PetitParser">build: aParser prefix: aChoiceParser 	^ aChoiceParser star , aParser 		map: [: ops : term | ops reverse inject: term into: [: result : operator | operator first value: operator petitSecond value: result ]]</body>

<body package="PetitParser">build: aParser right: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldRight: [ :a :op :b | op first value: a value: op petitSecond value: b ]</body>

<body package="PetitParser">buildOn: aParser	^ self buildSelectors inject: aParser into: [ :term :selector |		| list |		list := operators at: selector ifAbsent: [ #() ].		list isEmpty			ifTrue: [ term ]			ifFalse: [				self					perform: selector with: term 					with: (list size = 1						ifTrue: [ list first first ==&gt; [ :operator | Array with: list first petitSecond with: operator ] ]						ifFalse: [ 							list								inject: PPChoiceParser new								into: [ :choice :each | choice / (each first ==&gt; [ :operator | Array with: each petitSecond with: operator ]) ] ]) ] ]</body>

<body package="PetitParser">buildSelectors	^ #(build:prefix: build:postfix: build:right: build:left:)</body>

<body package="PetitParser">operator: aSymbol parser: aParser do: aBlock	parser isNil		ifTrue: [ ^ self error: 'You did not specify a term when creating the receiver.' ].	operators isNil		ifTrue: [ ^ self error: 'Use #group: to define precedence groups in descending order.' ].	(operators at: aSymbol ifAbsentPut: [ OrderedCollection new ])		addLast: (Array with: aParser asParser with: aBlock)</body>
</methods>

<methods>
<class-id>PetitParser.PPCharSetPredicate</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character value: index)) ]</body>
</methods>

<methods>
<class-id>PetitParser.PPCharSetPredicate</class-id> <category>evaluating</category>

<body package="PetitParser">value: aCharacter	| index |	index := aCharacter asInteger.	index == 0		ifTrue: [ ^ block value: aCharacter ].	index &gt; 255		ifTrue: [ ^ block value: aCharacter ].	^ classification at: index</body>
</methods>

<methods>
<class-id>PetitParser.PPCharSetPredicate class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aBlock	^ self basicNew initializeOn: aBlock</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateObjectParser</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateObjectParser</class-id> <category>operators</category>

<body package="PetitParser">negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateObjectParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	^ ( aStream atEnd not and: [ predicate value: aStream peek ]) 		ifFalse: [ PPFailure message: predicateMessage stream: aStream ]		ifTrue: [ aStream next ]</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString</body>

<body package="PetitParser">on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>factory-objects</category>

<body package="PetitParser">any	^ self		on: [ :each | true ] message: 'input expected'		negated: [ :each | false ] message: 'no input expected'</body>

<body package="PetitParser">anyExceptAnyOf: aCollectionOfChars	^ self		on: [ :each | (aCollectionOfChars includes: each) not ] message: 'any except ' , aCollectionOfChars printString , ' expected'		negated: [ :each | aCollectionOfChars includes: each ] message: aCollectionOfChars printString ,  ' not expected'</body>

<body package="PetitParser">anyOf: anArray	^ self		on: [ :each | anArray includes: each ] message: 'any of ' , anArray printString , ' expected'		negated: [ :each | (anArray includes: each) not ] message: 'none of ' , anArray printString ,  'expected'</body>

<body package="PetitParser">between: min and: max	^ self		on: [ :each | each &gt;= min and: [ each &lt;= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each &lt; min or: [ each &gt; max ] ] message: min printString , '..' , max printString , ' not expected'</body>

<body package="PetitParser">expect: anObject	^ self expect: anObject message: anObject printString , ' expected'</body>

<body package="PetitParser">expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>factory-chars</category>

<body package="PetitParser">blank	^ self chars: (String with: Character space with: Character tab) message: 'blank expected'</body>

<body package="PetitParser">char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'</body>

<body package="PetitParser">char: aCharacter message: aString	^ self expect: aCharacter message: aString</body>

<body package="PetitParser">chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString</body>

<body package="PetitParser">cr	^ self char: Character cr message: 'carriage return expected'</body>

<body package="PetitParser">digit	^ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected'</body>

<body package="PetitParser">hex	^ self 		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected'</body>

<body package="PetitParser">letter	^ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected'</body>

<body package="PetitParser">lf	^ self char: Character lf</body>

<body package="PetitParser">lowercase	^ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected'</body>

<body package="PetitParser">newline	^ self chars: (String with: Character cr with: Character lf) message: 'newline expected'</body>

<body package="PetitParser">punctuation	^ self chars: '.,"''?!;:#$%&amp;()*+-/&lt;&gt;=@[]\^_{}|~' message: 'punctuation expected'</body>

<body package="PetitParser">space	^ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected'</body>

<body package="PetitParser">tab	^ self char: Character tab message: 'tab expected'</body>

<body package="PetitParser">uppercase	^ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected'</body>

<body package="PetitParser">word	^ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected'</body>
</methods>

<methods>
<class-id>PetitParser.PPWrappingParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	^ block value: aStream value: [ parser parseOn: aStream ]</body>
</methods>

<methods>
<class-id>PetitParser.PPStream</class-id> <category>accessing</category>

<body package="PetitParser">current	^ collection at: position</body>

<body package="PetitParser">next: anInteger 	"Answer up to anInteger elements of my collection. Overridden for efficiency."	| answer endPosition |	endPosition := position + anInteger min: readLimit.	answer := collection copyFrom: position + 1 to: endPosition.	position := endPosition.	^ answer</body>

<body package="PetitParser">peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd 		ifTrue: [ nil ]		ifFalse: [ collection at: position + 1 ]</body>

<body package="PetitParser">position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPStream</class-id> <category>printing</category>

<body package="PetitParser">printOn: aStream	aStream 		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '·';		nextPutAll: (collection copyFrom: position + 1 to: readLimit)</body>
</methods>

<methods>
<class-id>PetitParser.PPStream</class-id> <category>converting</category>

<body package="PetitParser">asPetitStream	^ self</body>
</methods>

<methods>
<class-id>PetitParser.PPStream</class-id> <category>failures</category>

<body package="PetitParser">furthestFailure	" the failure with the largest position "	^ furthestFailure</body>

<body package="PetitParser">noteFailure: aPPFailure	" if a parser combination contains a choice parser, it is useful to to know the failure of the 'best' alternative "		( furthestFailure isNil or: [ aPPFailure position &gt; furthestFailure position ]) 		ifTrue: [ furthestFailure := aPPFailure ].</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenParser</class-id> <category>accessing</category>

<body package="PetitParser">tokenClass	^ tokenClass</body>

<body package="PetitParser">tokenClass: aTokenClass	tokenClass := aTokenClass</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenParser</class-id> <category>private</category>

<body package="PetitParser">create: aCollection start: aStartInteger stop: aStopInteger	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger</body>

<body package="PetitParser">defaultTokenClass	^ PPToken</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenParser</class-id> <category>initialization</category>

<body package="PetitParser">initialize	tokenClass := self defaultTokenClass</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>accessing</category>

<body package="PetitParser">collection	"Answer the underlying collection of this token."	^ collection</body>

<body package="PetitParser">size	"Answer the size of this token."	^ stop - start + 1</body>

<body package="PetitParser">start	"Answer the start position of this token in the underlying collection."	^ start</body>

<body package="PetitParser">stop	"Answer the stop position of this token in the underlying collection."		^ stop</body>

<body package="PetitParser">value	"Answer the contents of this token."	^ collection copyFrom: start to: stop</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>comparing</category>

<body package="PetitParser">= anObject	^ self class = anObject class and: [ self value = anObject value ]</body>

<body package="PetitParser">hash	^ self value hash</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>printing</category>

<body package="PetitParser">printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self value; nextPut: $)</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>copying</category>

<body package="PetitParser">copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>querying</category>

<body package="PetitParser">column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(self newline , [ :stream |		start &lt;= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position</body>

<body package="PetitParser">line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(self newline , [ :stream |		start &lt;= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line</body>
</methods>

<methods>
<class-id>PetitParser.PPToken</class-id> <category>private</category>

<body package="PetitParser">newline	"Parser a platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	^ (Character lf asParser)	/ (Character cr asParser , Character lf asParser optional)</body>
</methods>

<methods>
<class-id>PetitParser.PPToken class</class-id> <category>instance creation</category>

<body package="PetitParser">new	self error: 'Token can only be created using a dedicated constructor.'</body>

<body package="PetitParser">on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size</body>

<body package="PetitParser">on: aSequenceableCollection start: aStartInteger stop: aStopInteger	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger</body>
</methods>

<methods>
<class-id>PetitParser.PPMemento</class-id> <category>actions</category>

<body package="PetitParser">increment	count := count + 1</body>
</methods>

<methods>
<class-id>PetitParser.PPMemento</class-id> <category>initialization</category>

<body package="PetitParser">initialize	count := 0</body>
</methods>

<methods>
<class-id>PetitParser.PPMemento</class-id> <category>accessing</category>

<body package="PetitParser">position	^ position</body>

<body package="PetitParser">position: anInteger	position := anInteger</body>

<body package="PetitParser">result	^ result</body>

<body package="PetitParser">result: anObject	result := anObject</body>
</methods>

<methods>
<class-id>PetitParser.PPMemento</class-id> <category>accessing-readonly</category>

<body package="PetitParser">count	^ count</body>
</methods>

<methods>
<class-id>PetitParser.PPMemento class</class-id> <category>instance creation</category>

<body package="PetitParser">new	^ self basicNew initialize</body>
</methods>

<methods>
<class-id>PetitParser.PPFailure</class-id> <category>accessing</category>

<body package="PetitParser">message	"Answer a human readable error message of this parse failure."		^ message</body>

<body package="PetitParser">position	"Answer the position in the source string that caused this parse failure."	^ position</body>
</methods>

<methods>
<class-id>PetitParser.PPFailure</class-id> <category>testing</category>

<body package="PetitParser">isPetitFailure	"I am the only class that should implement this method to return true."	^ true</body>
</methods>

<methods>
<class-id>PetitParser.PPFailure</class-id> <category>printing</category>

<body package="PetitParser">printOn: aStream	aStream nextPutAll: self message; nextPutAll: ' at '; print: position</body>
</methods>

<methods>
<class-id>PetitParser.PPFailure</class-id> <category>initialization</category>

<body package="PetitParser">initializeMessage: aString at: anInteger 	message := aString.	position := anInteger.</body>
</methods>

<methods>
<class-id>PetitParser.PPFailure class</class-id> <category>instance creation</category>

<body package="PetitParser">message: aString at: anInteger	^ self basicNew initializeMessage: aString at: anInteger</body>

<body package="PetitParser">message: aString stream: aStream	| failure |	failure :=  self basicNew 		initializeMessage: aString at: aStream position;		yourself.	aStream noteFailure: failure.	^ failure</body>
</methods>

<methods>
<class-id>PetitParser.PPPluggableParser</class-id> <category>initialization</category>

<body package="PetitParser">initializeOn: aBlock	block := aBlock</body>
</methods>

<methods>
<class-id>PetitParser.PPPluggableParser</class-id> <category>accessing</category>

<body package="PetitParser">block	"Answer the pluggable block."	^ block</body>
</methods>

<methods>
<class-id>PetitParser.PPPluggableParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| position result |	position := aStream position.	result := block value: aStream.	result isPetitFailure 		ifTrue: [ aStream position: position ].	^ result</body>
</methods>

<methods>
<class-id>PetitParser.PPPluggableParser class</class-id> <category>instance creation</category>

<body package="PetitParser">on: aBlock	^ self new initializeOn: aBlock</body>
</methods>

<methods>
<class-id>PetitParser.PPFailingParser</class-id> <category>accessing</category>

<body package="PetitParser">message	"Answer the error message of the receiving parser."	^ message</body>
</methods>

<methods>
<class-id>PetitParser.PPFailingParser</class-id> <category>initialization</category>

<body package="PetitParser">setMessage: aString	message := aString</body>
</methods>

<methods>
<class-id>PetitParser.PPFailingParser</class-id> <category>printing</category>

<body package="PetitParser">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message</body>
</methods>

<methods>
<class-id>PetitParser.PPFailingParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	^ PPFailure message: message stream: aStream</body>
</methods>

<methods>
<class-id>PetitParser.PPFailingParser class</class-id> <category>instance creation</category>

<body package="PetitParser">message: aString	^ self new setMessage: aString</body>
</methods>

<methods>
<class-id>PetitParser.PPEpsilonParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	^ nil</body>
</methods>

<methods>
<class-id>PetitParser.PPUnresolvedParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream	self error: self printString , ' need to be resolved before execution.'</body>
</methods>

<methods>
<class-id>PetitParser.PPUnresolvedParser</class-id> <category>testing</category>

<body package="PetitParser">isUnresolved	^ true</body>
</methods>

<methods>
<class-id>PetitParser.PPOptionalParser</class-id> <category>parsing</category>

<body package="PetitParser">parseOn: aStream 	| element |	element := parser parseOn: aStream.	^ element isPetitFailure 		ifTrue: [ nil ]		ifFalse: [ element ]</body>
</methods>

<do-it>"Imported Classes:"</do-it>

<do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it>

<class>
<name>Object</name>
<environment>Core</environment>
<super></super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Kernel-Objects</category>
<attributes>
<package>Kernel-Objects</package>
</attributes>
</class>

<class>
<name>Stream</name>
<environment>Core</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports>
			private IOConstants.*
			</imports>
<category>Collections-Streams</category>
<attributes>
<package>Collections-Streams</package>
</attributes>
</class>

<class>
<name>PositionableStream</name>
<environment>Core</environment>
<super>Core.PeekableStream</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>collection position readLimit writeLimit policy </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Streams</category>
<attributes>
<package>Collections-Streams</package>
</attributes>
</class>

<class>
<name>Character</name>
<environment>Core</environment>
<super>Core.Magnitude</super>
<private>false</private>
<indexed-type>immediate</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Magnitude-General</category>
<attributes>
<package>Magnitude-General</package>
</attributes>
</class>

<class>
<name>BufferedExternalStream</name>
<environment>OS</environment>
<super>OS.ExternalStream</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>lineEndCharacter binary lineEndConvention bufferType ioBuffer ioConnection </inst-vars>
<class-inst-vars></class-inst-vars>
<imports>
			private OS.IOConstants.*
			</imports>
<category>OS-Streaming</category>
<attributes>
<package>OS-Streaming</package>
</attributes>
</class>

<class>
<name>BlockContext</name>
<environment>Kernel</environment>
<super>Kernel.Context</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Kernel-Methods</category>
<attributes>
<package>Kernel-Methods</package>
</attributes>
</class>

<class>
<name>BlockClosure</name>
<environment>Kernel</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>method outerContext copiedValues </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Kernel-Methods</category>
<attributes>
<package>Kernel-Methods</package>
</attributes>
</class>

<class>
<name>SequenceableCollection</name>
<environment>Core</environment>
<super>Core.Collection</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Abstract</category>
<attributes>
<package>Collections-Abstract</package>
</attributes>
</class>

<class>
<name>String</name>
<environment>Core</environment>
<super>Core.CharacterArray</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Text</category>
<attributes>
<package>Collections-Text</package>
</attributes>
</class>

<class>
<name>Symbol</name>
<environment>Core</environment>
<super>Core.String</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Text</category>
<attributes>
<package>Collections-Text</package>
</attributes>
</class>

<class>
<name>Set</name>
<environment>Core</environment>
<super>Core.Collection</super>
<private>false</private>
<indexed-type>objects</indexed-type>
<inst-vars>tally </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Unordered</category>
<attributes>
<package>Collections-Unordered</package>
</attributes>
</class>

<class>
<name>UndefinedObject</name>
<environment>Core</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Kernel-Objects</category>
<attributes>
<package>Kernel-Objects</package>
</attributes>
</class>

<class>
<name>Text</name>
<environment>Core</environment>
<super>Core.CharacterArray</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>string runs </inst-vars>
<class-inst-vars></class-inst-vars>
<imports>
			private Graphics.TextConstants.*
			</imports>
<category>Collections-Text</category>
<attributes>
<package>Collections-Text</package>
</attributes>
</class>

<class>
<name>ReadStream</name>
<environment>Core</environment>
<super>Core.InternalStream</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Streams</category>
<attributes>
<package>Collections-Streams</package>
</attributes>
</class>

</st-source>
