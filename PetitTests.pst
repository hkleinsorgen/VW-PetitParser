<?xml version="1.0"?>

<st-source>
<!-- 
Name: PetitTests
Notice: PetitParser is licensed under the MIT license.
Comment: A port of the PetitParser

http://source.lukas-renggli.ch/petit.html
http://scg.unibe.ch/research/helvetia/petitparser

PetitParser is licensed under the MIT license.
DevelopmentPrerequisites: #(#(#any 'PetitParser-Preload' '') #(#any 'PetitParser' '') #(#any 'SUnitToo' ''))
Id: 67bc9f90-8f38-4275-9f7b-8c5fd3531fac
KSignature: #('definedClasses' 15 'definedClassesHash' 23907987600 'extendedClasses' 1 'extendedClassesHash' 109580705)
KSignatureV2: #('definedClasses' 15 'definedClassesHash' 657585062132690283322713721895051306123486413761 'extendedClasses' 1 'extendedClassesHash' 164702914641558907206498108192490653374277202696)
Namespace: PetitParser
PackageName: PetitTests
Parcel: #('PetitTests')
ParcelDirectory: e:\develop\git\jse\PetitTests
ParcelName: PetitTests
PrerequisiteDescriptions: #(#(#name 'PetitParser-Preload') #(#name 'PetitParser' #componentType #package) #(#name 'SUnitToo' #componentType #package))
PrerequisiteParcels: #(#('PetitParser-Preload' '') #('PetitParser' '') #('SUnitToo' ''))
TestCoverage: false
Url: http://source.lukas-renggli.ch/petit/PetitTests-lr.19.mcz
Date: 2:16:19 PM September 16, 2017
 -->
<time-stamp>From VisualWorks®, 8.1.1 of 10. März 2016 on 16. September 2017 at 14:16:19</time-stamp>


<do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it>

<class>
<name>PPAbstractParseTest</name>
<environment>PetitParser</environment>
<super>SUnit.TestCase</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Core</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPMappingTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPScriptingTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<comment>
<class-id>PetitParser.PPScriptingTest</class-id>
<body>These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html</body>
</comment>

<class>
<name>PPTokenTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPExtensionTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPCompositeParserTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>parser </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Core</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPArithmeticParserTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPCompositeParserTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPLambdaParserTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPCompositeParserTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPExpressionParserTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPArithmeticParserTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPParserResource</name>
<environment>PetitParser</environment>
<super>SUnit.TestResource</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>parsers </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Core</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPLambdaParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPCompositeParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>expression abstraction application variable </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Examples</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPArithmeticParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPCompositeParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>terms addition factors multiplication power primary parentheses number </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Examples</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPComposedTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPParserTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<class>
<name>PPPredicateTest</name>
<environment>PetitParser</environment>
<super>PetitParser.PPAbstractParseTest</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitTests-Tests</category>
<attributes>
<package>PetitTests</package>
</attributes>
</class>

<methods>
<class-id>Core.CharacterArray</class-id> <category>testing</category>

<body package="PetitTests">petitIncludesSubString: aCollection 	^ ( self indexOfSubCollection: aCollection startingAt: 1 ) &gt; 0</body>
</methods>

<methods>
<class-id>PetitParser.PPAbstractParseTest</class-id> <category>utilities</category>

<body package="PetitTests">assert: aParser fail: aCollection	| stream result |	self assert: aParser isPetitParser.	stream := aCollection asPetitStream.	result := aParser parse: stream.	self assert: result isPetitFailure.	self assert: stream position = 0</body>

<body package="PetitTests">assert: aParser parse: aCollection	self assert: aParser parse: aCollection to: nil end: aCollection size</body>

<body package="PetitTests">assert: aParser parse: aCollection end: anInteger	self assert: aParser parse: aCollection to: nil end: anInteger</body>

<body package="PetitTests">assert: aParser parse: aCollection to: anObject	self assert: aParser parse: aCollection to: anObject end: aCollection size</body>

<body package="PetitTests">assert: aParser parse: aParseObject to: aTargetObject end: anInteger	| stream result |	self assert: aParser isPetitParser.	stream := aParseObject asPetitStream.	result := aParser parse: stream.	aTargetObject isNil		ifTrue: [ self deny: result isPetitFailure ]		ifFalse: [ self assert: result = aTargetObject ].	self assert: stream position = anInteger</body>

<body package="PetitTests">assert: aParser parse: aParserObject toToken: from stop: to	| token |	token := PPToken on: aParserObject start: from stop: to.	^ self assert: aParser parse: aParserObject to: token</body>

<body package="PetitTests">assert: aParser parse: aParserObject toToken: from stop: to end: end	| token |	token := PPToken on: aParserObject start: from stop: to.	^ self assert: aParser parse: aParserObject to: token end: end</body>
</methods>

<methods>
<class-id>PetitParser.PPAbstractParseTest class</class-id> <category>testing</category>

<body package="PetitTests">isAbstract	^ self name = #PPAbstractParseTest</body>
</methods>

<methods>
<class-id>PetitParser.PPAbstractParseTest class</class-id> <category>accessing</category>

<body package="PetitTests">packageNamesUnderTest	^ #('PetitParser' 'PetitTests')</body>
</methods>

<methods>
<class-id>PetitParser.PPMappingTest</class-id> <category>testing</category>

<body package="PetitTests">testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)</body>

<body package="PetitTests">testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)</body>

<body package="PetitTests">testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))</body>

<body package="PetitTests">testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))</body>

<body package="PetitTests">testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)</body>

<body package="PetitTests">testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)</body>

<body package="PetitTests">testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)</body>
</methods>

<methods>
<class-id>PetitParser.PPScriptingTest</class-id> <category>tests</category>

<body package="PetitTests">testExpressionInterpreter	self 		assert: self expressionInterpreter		parse: '2*(3+4)'		to: 14</body>

<body package="PetitTests">testExpressionParser	self		assert: self expressionParser		parse: '2*(3+4)'		to: #($2 $* ($( ($3 $+ $4) $)))</body>

<body package="PetitTests">testSLassign		self assert: self straightLineParser		parse: 'abc:=1'		to: #(#($a #($b $c) ':=' #(#(#($1 #()) #()) #())) #())</body>

<body package="PetitTests">testSLprint	self 		assert: self straightLineParser		parse: 'print(3,4)'		to: #(('print' $( ((($3 ()) ()) () (($, ((($4 ()) ()) ())))) $)) ())</body>
</methods>

<methods>
<class-id>PetitParser.PPScriptingTest</class-id> <category>examples</category>

<body package="PetitTests">expressionInterpreter	"Same as #expressionInterpreter but with semantic actions."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 - $9) ==&gt; [ :token | token codePoint - $0 codePoint ].	add def: ((mul , $+ asParser , add) ==&gt; [ :nodes | (nodes at: 1) + (nodes at: 3) ])		/ mul.	mul def: ((prim , $* asParser , mul) ==&gt; [ :nodes | (nodes at: 1) * (nodes at: 3) ])		/ prim.	prim def: (($( asParser , add , $) asParser) ==&gt; [ :nodes | nodes at: 2 ])		/ dec.	^ add end</body>

<body package="PetitTests">expressionParser	"Simple demo of scripting an expression parser."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 - $9).	add def: (mul , $+ asParser , add)		/ mul.	mul def: (prim , $* asParser , mul)		/ prim.	prim def: ($( asParser , add , $) asParser)		/ dec.	^ add end</body>

<body package="PetitTests">straightLineParser	| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |	goal := PPUnresolvedParser new.	stmList := PPUnresolvedParser new.	stm := PPUnresolvedParser new.	exp := PPUnresolvedParser new.	expList := PPUnresolvedParser new.	mulExp := PPUnresolvedParser new.	primExp := PPUnresolvedParser new.		lower := $a - $z.	upper := $A - $Z.	char := lower / upper.	nonzero := $1 - $9.	dec := $0 - $9.	id := char, ( char / dec ) star.	num := $0 asParser / ( nonzero, dec star).	goal def: stmList end.	stmList def: stm , ( $; asParser, stm ) star.	stm def: ( id, ':=' asParser, exp )		/ ( 'print' asParser, $( asParser, expList, $) asParser ). 	exp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.	expList def: exp, ( $, asParser, exp ) star.	mulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.	primExp def: id		/ num		/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).	^ goal</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenTest</class-id> <category>testing</category>

<body package="PetitTests">testCollection	| input result |	input := 'foo    '.	result := self 		parse: input		using: self identifier.	self assert: (result collection = input).	self assert: (result collection == input)</body>

<body package="PetitTests">testNew	self should: [ PPToken new ] raise: Error.</body>

<body package="PetitTests">testPrinting	| result |	result := PPToken on: 'var'.	self assert: (result printString petitIncludesSubString: 'PPToken(var)')</body>

<body package="PetitTests">testSize	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result size = 3</body>

<body package="PetitTests">testStart	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result start = 1</body>

<body package="PetitTests">testStop	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result stop = 3</body>

<body package="PetitTests">testValue	| input result |	input := 'foo'.	result := self 		parse: input		using: self identifier.	self assert: result value = input.	self deny: result value == input</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenTest</class-id> <category>testing-copying</category>

<body package="PetitTests">testCopyFromTo	| result other |	result := PPToken on: 'abc'.	other := result copyFrom: 2 to: 2.		self assert: other size = 1.	self assert: other start = 2.	self assert: other stop = 2.	self assert: other collection = result collection</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenTest</class-id> <category>testing-comparing</category>

<body package="PetitTests">testEquality	| token1 token2 |	token1 := self  parse: 'foo' using: self identifier.	token2 := self  parse: 'foo' using: self identifier.	self deny: token1 == token2.	self assert: token1 = token2.	self assert: token1 hash = token2 hash.</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenTest</class-id> <category>utilities</category>

<body package="PetitTests">parse: aString using: aParser	^ aParser parse: aString</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenTest</class-id> <category>testing-querying</category>

<body package="PetitTests">testColumn	| input parser result |	input := '1' , (String with: Character cr) , '12' , (String with: Character cr with: Character lf) , '123' , (String with: Character lf) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result 		with:  #(1 2 1 2 3 4 1 2 3 4 1 2 3 4)		do: [ :token :line | self assert: token column = line ]</body>

<body package="PetitTests">testLine	| input parser result |	input := '1' , (String with: Character cr) , '12' , (String with: Character cr with: Character lf) , '123' , (String with: Character lf) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result 		with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) 		do: [ :token :line | self assert: token line = line ]</body>
</methods>

<methods>
<class-id>PetitParser.PPTokenTest</class-id> <category>accessing</category>

<body package="PetitTests">identifier	^ #word asParser plus token</body>
</methods>

<methods>
<class-id>PetitParser.PPExtensionTest</class-id> <category>testing-stream</category>

<body package="PetitTests">testStream	| stream |	stream := 'abc' readStream asPetitStream.	self assert: (stream class = PPStream).	self assert: (stream printString = '·abc').	self assert: (stream peek) = $a.	self assert: (stream next) = $a.	self assert: (stream printString = 'a·bc').	self assert: (stream asPetitStream = stream)</body>

<body package="PetitTests">testText	| stream |	stream := 'abc' asText asPetitStream.	self assert: stream class = PPStream</body>
</methods>

<methods>
<class-id>PetitParser.PPExtensionTest</class-id> <category>testing-parser</category>

<body package="PetitTests">testCharacter	| parser |	parser := $a asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testClosure	| parser |	parser :=		[: stream | stream upTo: $s ] asParser.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 's' to: ''.	self assert: parser parse: 'as' to: 'a'.	self assert: parser parse: 'aas' to: 'aa'.	self assert: parser parse: 'sa' to: '' end: 1.	self assert: parser parse: 'saa' to: '' end: 1.	parser :=		[: stream |			stream upTo: $s.			PPFailure message: 'stream' stream: stream		] asParser.	self assert: parser fail: ''.	self assert: parser fail: 's'.	self assert: parser fail: 'as'.</body>

<body package="PetitTests">testEpsilon	| parser |	parser := nil asParser.	self assert: parser asParser = parser</body>

<body package="PetitTests">testOrdered	| parser |	parser := #(1 2) asParser.	self assert: parser parse: #(1 2) to: #(1 2).	self assert: parser parse: #(1 2 3) to: #(1 2) end: 2.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 1).	self assert: parser fail: #(1 1 2)</body>

<body package="PetitTests">testParser	| parser |	parser := $a asParser.	self assert: parser asParser = parser</body>

<body package="PetitTests">testRange	| parser |	parser := $a - $c.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser fail: 'd'</body>

<body package="PetitTests">testString	| parser |	parser := 'ab' asParser.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aba' to: 'ab' end: 2.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser fail: 'a'.	self assert: parser fail: 'ac'</body>

<body package="PetitTests">testSymbol	| parser |	parser := #any asParser.	self assert: parser parse: 'a'.	self assert: parser fail: ''</body>

<body package="PetitTests">testUnordered	| parser |	parser := #(1 2) asSet asParser.	self assert: parser parse: #(1) to: 1.	self assert: parser parse: #(2) to: 2.	self assert: parser parse: #(1 2) to: 1 end: 1.	self assert: parser parse: #(2 1) to: 2 end: 1.	self assert: parser fail: #().	self assert: parser fail: #(3)</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParserTest</class-id> <category>accessing</category>

<body package="PetitTests">parserClass	self subclassResponsibility</body>

<body package="PetitTests">parserInstance	^ PPParserResource current parserAt: self parserClass</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParserTest</class-id> <category>running</category>

<body package="PetitTests">setUp	super setUp.	parser := self parserInstance</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParserTest</class-id> <category>utilities</category>

<body package="PetitTests">assert: aCollection is: anObject	| result |	result := self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true</body>

<body package="PetitTests">parse: aString	^ parser		parse: aString		onError: [ :err :pos | self error: err ]</body>

<body package="PetitTests">parse: aString production: aSymbol	^ (parser productionAt: aSymbol)		parse: aString		onError: [ :err :pos | self error: err ].</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParserTest class</class-id> <category>accessing</category>

<body package="PetitTests">resources	^ Array with: PPParserResource</body>
</methods>

<methods>
<class-id>PetitParser.PPCompositeParserTest class</class-id> <category>testing</category>

<body package="PetitTests">isAbstract	^ self name = #PPCompositeParserTest</body>
</methods>

<methods>
<class-id>PetitParser.PPArithmeticParserTest</class-id> <category>testing-operations</category>

<body package="PetitTests">testAdd	self assert: '1 + 2' is: 3.	self assert: '2 + 1' is: 3.	self assert: '1 + 2.3' is: 3.3.	self assert: '2.3 + 1' is: 3.3.	self assert: '1 + -2' is: -1.	self assert: '-2 + 1' is: -1</body>

<body package="PetitTests">testAddMany	self assert: '1' is: 1.	self assert: '1 + 2' is: 3.	self assert: '1 + 2 + 3' is: 6.	self assert: '1 + 2 + 3 + 4' is: 10.	self assert: '1 + 2 + 3 + 4 + 5' is: 15</body>

<body package="PetitTests">testDiv	self assert: '12 / 3' is: 4.	self assert: '-16 / -4' is: 4</body>

<body package="PetitTests">testDivMany	self assert: '100 / 2' is: 50.	self assert: '100 / 2 / 2' is: 25.	self assert: '100 / 2 / 2 / 5' is: 5.	self assert: '100 / 2 / 2 / 5 / 5' is: 1</body>

<body package="PetitTests">testMul	self assert: '2 * 3' is: 6.	self assert: '2 * -4' is: -8</body>

<body package="PetitTests">testMulMany	self assert: '1 * 2' is: 2.	self assert: '1 * 2 * 3' is: 6.	self assert: '1 * 2 * 3 * 4' is: 24.	self assert: '1 * 2 * 3 * 4 * 5' is: 120</body>

<body package="PetitTests">testPow	self assert: '2 ^ 3' is: 8.	self assert: '-2 ^ 3' is: -8.	self assert: '-2 ^ -3' is: -0.125</body>

<body package="PetitTests">testPowMany	self assert: '4 ^ 3' is: 64.	self assert: '4 ^ 3 ^ 2' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1 ^ 0' is: 262144</body>

<body package="PetitTests">testSub	self assert: '1 - 2' is: -1.	self assert: '1.2 - 1.2' is: 0.	self assert: '1 - -2' is: 3.	self assert: '-1 - -2' is: 1</body>

<body package="PetitTests">testSubMany	self assert: '1' is: 1.	self assert: '1 - 2' is: -1.	self assert: '1 - 2 - 3' is: -4.	self assert: '1 - 2 - 3 - 4' is: -8.	self assert: '1 - 2 - 3 - 4 - 5' is: -13</body>
</methods>

<methods>
<class-id>PetitParser.PPArithmeticParserTest</class-id> <category>accessing</category>

<body package="PetitTests">parserClass	^ PPArithmeticParser</body>
</methods>

<methods>
<class-id>PetitParser.PPArithmeticParserTest</class-id> <category>testing</category>

<body package="PetitTests">testNum	self assert: '0' is: 0.	self assert: '0.0' is: 0.0.	self assert: '1' is: 1.	self assert: '1.2' is: 1.2.	self assert: '34' is: 34.	self assert: '56.78' is: 56.78.	self assert: '-9' is: -9.	self assert: '-9.9' is: -9.9</body>
</methods>

<methods>
<class-id>PetitParser.PPArithmeticParserTest</class-id> <category>testing-expression</category>

<body package="PetitTests">testBrackets	self assert: '(1)' is: 1.	self assert: '(1 + 2)' is: 3.		self assert: '((1))' is: 1.	self assert: '((1 + 2))' is: 3.	self assert: '2 * (3 + 4)' is: 14.	self assert: '(2 + 3) * 4' is: 20.	self assert: '6 / (2 + 4)' is: 1.	self assert: '(2 + 6) / 2' is: 4</body>

<body package="PetitTests">testPriority	self assert: '2 * 3 + 4' is: 10.	self assert: '2 + 3 * 4' is: 14.	self assert: '6 / 3 + 4' is: 6.	self assert: '2 + 6 / 2' is: 5</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParserTest</class-id> <category>testing-curch</category>

<body package="PetitTests">testAnd	self assert: self parserClass and = #('p' ('q' (('p' 'q') 'p')))</body>

<body package="PetitTests">testFalse	self assert: self parserClass false = #('x' ('y' 'y'))</body>

<body package="PetitTests">testIfThenElse	self assert: self parserClass ifthenelse = #('p' 'p')</body>

<body package="PetitTests">testNot	self assert: self parserClass not = #('p' ('a' ('b' (('p' 'b') 'a'))))</body>

<body package="PetitTests">testOr	self assert: self parserClass or = #('p' ('q' (('p' 'p') 'q')))</body>

<body package="PetitTests">testTrue	self assert: self parserClass true = #('x' ('y' 'x'))</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParserTest</class-id> <category>testing</category>

<body package="PetitTests">testAbstraction	self assert: '\x.y' is: #('x' 'y').	self assert: '\x.\y.z' is: #('x' ('y' 'z'))</body>

<body package="PetitTests">testApplication	self assert: '(x x)' is: #('x' 'x').	self assert: '(x y)' is: #('x' 'y').	self assert: '((x y) z)' is: #(('x' 'y') 'z').	self assert: '(x (y z))' is: #('x' ('y' 'z'))</body>

<body package="PetitTests">testVariable	self assert: 'x' is: 'x'.	self assert: 'xy' is: 'xy'.	self assert: 'x12' is: 'x12'</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParserTest</class-id> <category>accessing</category>

<body package="PetitTests">parserClass	^ PPLambdaParser</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParserTest</class-id> <category>testing-utilities</category>

<body package="PetitTests">testParseOnError	| result beenHere |	result := self parserClass		parse: '\x.y'		onError: [ self signalFailure: 'Parsing failed' ].	self assert: result = #('x' 'y').		beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ beenHere := true ].	self assert: beenHere.		beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :fail | beenHere := true. fail ].	self assert: beenHere."	self assert: (result message petitIncludesSubString: '$(')."	self assert: (result message petitIncludesSubString: 'expected')."	self assert: (result position = 0)."	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :msg :pos | 			"self assert: (msg petitIncludesSubString: '$(')."			self assert: (msg petitIncludesSubString: 'expected').			"self assert: (pos = 0)."			beenHere := true ].	self assert: result.	self assert: beenHere</body>

<body package="PetitTests">testParseStartingAtOnError	| result beenHere |	result := self parserClass		parse: 'x'		startingAt: #variable		onError: [ self signalFailure: 'Parsing failed' ].	self assert: result = 'x'.		beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ beenHere := true ].	self assert: beenHere.		beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :fail | beenHere := true. fail ].	self assert: beenHere.	self assert: result message = 'letter expected'.	self assert: result position = 0.	beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :msg :pos | 			self assert: msg = 'letter expected'.			self assert: pos = 0.			beenHere := true ].	self assert: beenHere</body>

<body package="PetitTests">testProductionAt	self assert: (parser productionAt: #foo) isNil.	self assert: (parser productionAt: #foo ifAbsent: [ true ]).		self assert: (parser productionAt: #start) notNil.	self assert: (parser productionAt: #start ifAbsent: [ true ]) notNil.		self assert: (parser productionAt: #variable) notNil.	self assert: (parser productionAt: #variable ifAbsent: [ true ]) notNil</body>
</methods>

<methods>
<class-id>PetitParser.PPExpressionParserTest</class-id> <category>testing</category>

<body package="PetitTests">testPostfixAdd	self assert: '0++' is: 1.	self assert: '0++++' is: 2.	self assert: '0++++++' is: 3.	self assert: '0+++1' is: 2.	self assert: '0+++++1' is: 3.	self assert: '0+++++++1' is: 4</body>

<body package="PetitTests">testPostfixSub	self assert: '1--' is: 0.	self assert: '2----' is: 0.	self assert: '3------' is: 0.	self assert: '2---1' is: 0.	self assert: '3-----1' is: 0.	self assert: '4-------1' is: 0.</body>

<body package="PetitTests">testPrefixNegate	self assert: '1' is: 1.	self assert: '-1' is: -1.	self assert: '--1' is: 1.	self assert: '---1' is: -1</body>
</methods>

<methods>
<class-id>PetitParser.PPExpressionParserTest</class-id> <category>accessing</category>

<body package="PetitTests">parserInstance	| expression parens number |	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim		==&gt; [ :nodes | nodes petitSecond ].	number := (#digit asParser plus , ($. asParser , #digit asParser plus) optional) token trim		==&gt; [ :token | token value asNumber ].	expression term: parens / number.	expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].	^ expression end</body>
</methods>

<methods>
<class-id>PetitParser.PPExpressionParserTest class</class-id> <category>testing</category>

<body package="PetitTests">shouldInheritSelectors	^ true</body>
</methods>

<methods>
<class-id>PetitParser.PPParserResource</class-id> <category>accessing</category>

<body package="PetitTests">parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]</body>
</methods>

<methods>
<class-id>PetitParser.PPParserResource</class-id> <category>running</category>

<body package="PetitTests">setUp	super setUp.	parsers := Dictionary new</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParser</class-id> <category>accessing</category>

<body package="PetitTests">start	^ expression end</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParser</class-id> <category>productions</category>

<body package="PetitTests">abstraction	^ ( $\ asParser token trim , variable , $. asParser token trim , expression ) ==&gt; [: node | Array with: node petitSecond with: ( node at: 4 )]</body>

<body package="PetitTests">application	^ $( asParser token trim , expression , expression , $) asParser token trim ==&gt; [ :node | Array with: node petitSecond with: node petitThird ]</body>

<body package="PetitTests">expression	^ variable / abstraction / application</body>

<body package="PetitTests">variable	^ (#letter asParser , #word asParser star) token trim ==&gt; [ :token | token value ]</body>
</methods>

<methods>
<class-id>PetitParser.PPLambdaParser class</class-id> <category>curch-booleans</category>

<body package="PetitTests">and	^ self parse: '\p.\q.((p q) p)'</body>

<body package="PetitTests">false	^ self parse: '\x.\y.y'</body>

<body package="PetitTests">ifthenelse	^ self parse: '\p.p'</body>

<body package="PetitTests">not	^ self parse: '\p.\a.\b.((p b) a)'</body>

<body package="PetitTests">or	^ self parse: '\p.\q.((p p) q)'</body>

<body package="PetitTests">true	^ self parse: '\x.\y.x'</body>
</methods>

<methods>
<class-id>PetitParser.PPArithmeticParser</class-id> <category>grammar</category>

<body package="PetitTests">addition	^ (factors separatedBy: ($+ asParser / $- asParser) token trim) 		foldLeft: [ :a :op :b | a perform: op value asSymbol with: b ]</body>

<body package="PetitTests">factors	^ multiplication / power</body>

<body package="PetitTests">multiplication	^ (power separatedBy: ($* asParser / $/ asParser) token trim)		foldLeft: [ :a :op :b | a perform: op value asSymbol with: b ]</body>

<body package="PetitTests">number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) token trim ==&gt; [ :token | token value asNumber ]</body>

<body package="PetitTests">parentheses	^ $( asParser flatten trim , terms , $) asParser flatten trim ==&gt; #petitSecond</body>

<body package="PetitTests">power	^ (primary separatedBy: $^ asParser token trim) foldRight: [ :a :op :b | a raisedTo: b ]</body>

<body package="PetitTests">primary	^ number / parentheses</body>

<body package="PetitTests">terms	^ addition / factors</body>
</methods>

<methods>
<class-id>PetitParser.PPArithmeticParser</class-id> <category>accessing</category>

<body package="PetitTests">start	^ terms end</body>
</methods>

<methods>
<class-id>PetitParser.PPComposedTest</class-id> <category>testing-examples</category>

<body package="PetitTests">testComment	self assert: self comment parse: '""' to: '""'.	self assert: self comment parse: '"a"' to: '"a"'.	self assert: self comment parse: '"ab"' to: '"ab"'.	self assert: self comment parse: '"abc"' to: '"abc"'.	self assert: self comment parse: '""a' to: '""' end: 2.	self assert: self comment parse: '"a"a' to: '"a"' end: 3.	self assert: self comment parse: '"ab"a' to: '"ab"' end: 4.	self assert: self comment parse: '"abc"a' to: '"abc"' end: 5.	self assert: self comment fail: '"'.	self assert: self comment fail: '"a'.	self assert: self comment fail: '"aa'.	self assert: self comment fail: 'a"'.	self assert: self comment fail: 'aa"'</body>

<body package="PetitTests">testIdentifier	self assert: self identifier parse: 'a' to: 'a'.	self assert: self identifier parse: 'a1' to: 'a1'.	self assert: self identifier parse: 'a12' to: 'a12'.	self assert: self identifier parse: 'ab' to: 'ab'.	self assert: self identifier parse: 'a1b' to: 'a1b'.	self assert: self identifier parse: 'a_' to: 'a' end: 1.	self assert: self identifier parse: 'a1-' to: 'a1' end: 2.	self assert: self identifier parse: 'a12+' to: 'a12' end: 3.	self assert: self identifier parse: 'ab^' to: 'ab' end: 2.	self assert: self identifier parse: 'a1b*' to: 'a1b' end: 3.	self assert: self identifier fail: ''.	self assert: self identifier fail: '1'.	self assert: self identifier fail: '1a'</body>

<body package="PetitTests">testNumber	self assert: self number parse: '1' to: '1'.	self assert: self number parse: '12' to: '12'.	self assert: self number parse: '12.3' to: '12.3'.	self assert: self number parse: '12.34' to: '12.34'.	self assert: self number parse: '1..' to: '1' end: 1.	self assert: self number parse: '12-' to: '12' end: 2.	self assert: self number parse: '12.3.' to: '12.3' end: 4.	self assert: self number parse: '12.34.' to: '12.34' end: 5.		self assert: self number parse: '-1' to: '-1'.	self assert: self number parse: '-12' to: '-12'.	self assert: self number parse: '-12.3' to: '-12.3'.	self assert: self number parse: '-12.34' to: '-12.34'.		self assert: self number fail: ''.	self assert: self number fail: '-'.	self assert: self number fail: '.'.	self assert: self number fail: '.1'</body>

<body package="PetitTests">testReturn	| number spaces return |	number := #digit asParser plus token.	spaces := #space asParser star.	return := (spaces , $^ asParser token , spaces , number)		==&gt; [ :nodes | Array with: #return with: (nodes at: 4) value ].	self assert: return parse: '^1' to: #(return '1').	self assert: return parse: '^12' to: #(return '12').	self assert: return parse: '^ 123' to: #(return '123').	self assert: return parse: '^  1234' to: #(return '1234').		self assert: return fail: '1'.	self assert: return fail: '^'</body>
</methods>

<methods>
<class-id>PetitParser.PPComposedTest</class-id> <category>testing</category>

<body package="PetitTests">testDoubledString	| parser |	parser := ($' asParser , (($' asParser , $' asParser) / $' asParser negate) star flatten , $' asParser) 		==&gt; [ :nodes | nodes petitSecond copyReplaceAll: '''''' with: '''' ].	self assert: parser parse: '''''' to: ''.	self assert: parser parse: '''a''' to: 'a'.	self assert: parser parse: '''ab''' to: 'ab'.	self assert: parser parse: '''a''''b''' to: 'a''b'.	self assert: parser parse: '''a''''''''b''' to: 'a''''b'</body>

<body package="PetitTests">testIfThenElse	"S ::= if C then S else S | if C then S | X"	| start if then else cond expr parser |	start := PPUnresolvedParser new.	if := 'if' asParser token trim.	then := 'then' asParser token trim.	else := 'else' asParser token trim.	cond := 'C' asParser token trim.	expr := 'X' asParser token trim.	start def: (if , cond , then , start , else , start) / (if , cond , then , start) / expr.	parser := start end.	self assert: parser parse: 'X'.	self assert: parser parse: 'if C then X'.	self assert: parser parse: 'if C then X else X'.	self assert: parser parse: 'if C then if C then X'.	self assert: parser parse: 'if C then if C then X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X else X'.	self assert: parser fail: 'if C'.	self assert: parser fail: 'if C else X'.	self assert: parser fail: 'if C then if C'</body>

<body package="PetitTests">testLeftRecursion	"S ::= S 'x' S / '1'"		| parser |	parser := PPUnresolvedParser new.	parser def: ((parser , $x asParser , parser) / $1 asParser) memoized flatten.	self assert: parser parse: '1' to: '1'.	self assert: parser parse: '1x1' to: '1x1'.	self assert: parser parse: '1x1x1' to: '1x1x1'.	self assert: parser parse: '1x1x1x1' to: '1x1x1x1'.	self assert: parser parse: '1x1x1x1x1' to: '1x1x1x1x1'.	self assert: parser parse: '1x1x1x1x1x1' to: '1x1x1x1x1x1'</body>

<body package="PetitTests">testListOfIntegers	"S ::= S , number | number"		| number list parser |	number := #digit asParser plus token trim		==&gt; [ :node | node value asInteger ].	list := (number separatedBy: $, asParser token trim)		==&gt; [ :node | node select: [ :each | each isInteger ] ].	parser := list end.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1,2' to: (1 to: 2) asArray.	self assert: parser parse: '1,2,3' to: (1 to: 3) asArray.	self assert: parser parse: '1,2,3,4' to: (1 to: 4) asArray.	self assert: parser parse: '1,2,3,4,5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1, 2' to: (1 to: 2) asArray.	self assert: parser parse: '1, 2, 3' to: (1 to: 3) asArray.	self assert: parser parse: '1, 2, 3, 4' to: (1 to: 4) asArray.	self assert: parser parse: '1, 2, 3, 4, 5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1 ,2' to: (1 to: 2) asArray.	self assert: parser parse: '1 ,2 ,3' to: (1 to: 3) asArray.	self assert: parser parse: '1 ,2 ,3 ,4' to: (1 to: 4) asArray.	self assert: parser parse: '1 ,2 ,3 ,4 ,5' to: (1 to: 5) asArray.		self assert: parser fail: ''.	self assert: parser fail: ','.	self assert: parser fail: '1,'.	self assert: parser fail: '1,,2'</body>

<body package="PetitTests">testNestedComments	"C ::= B I* E"	"I ::= !E (C | T)"	"B ::= /*"	"E ::= */"	"T ::= ."		| begin end any inside parser |	begin := '/*' asParser.	end := '*/' asParser.	any := #any asParser.		parser := PPUnresolvedParser new.	inside := end not , (parser / any).	parser def: begin , inside star , end.		self assert: parser parse: '/*ab*/cd' end: 6.	self assert: parser parse: '/*a/*b*/c*/'.	self assert: parser fail: '/*a/*b*/c'</body>

<body package="PetitTests">testPalindrome	"S0 ::= a S1 a | b S1 b | ...	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPUnresolvedParser new.	s1 := PPUnresolvedParser new.	s0 def: ($a asParser , s1 , $a asParser)		/ ($b asParser , s1 , $b asParser)		/ ($c asParser , s1 , $c asParser).		s1 def: s0 / nil asParser.	parser := s0 flatten end.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'bb' to: 'bb'.	self assert: parser parse: 'cc' to: 'cc'.		self assert: parser parse: 'abba' to: 'abba'.	self assert: parser parse: 'baab' to: 'baab'.	self assert: parser parse: 'abccba' to: 'abccba'.	self assert: parser parse: 'abaaba' to: 'abaaba'.	self assert: parser parse: 'cbaabc' to: 'cbaabc'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'abccbb'</body>

<body package="PetitTests">testParseAaaBbb	"S0 ::= a S1 b	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPUnresolvedParser new.	s1 := PPUnresolvedParser new.	s0 def: $a asParser , s1 , $b asParser.	s1 def: s0 / nil asParser.	parser := s0 flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aabb' to: 'aabb'.	self assert: parser parse: 'aaabbb' to: 'aaabbb'.	self assert: parser parse: 'aaaabbbb' to: 'aaaabbbb'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'aabbb' to: 'aabb' end: 4.	self assert: parser parse: 'aaabbbb' to: 'aaabbb' end: 6.	self assert: parser parse: 'aaaabbbbb' to: 'aaaabbbb' end: 8.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'aaabb'</body>

<body package="PetitTests">testParseAaaaaa	"S ::= a a S | epsilon"		| s0 s1 parser |	s0 := PPUnresolvedParser new.	s1 := $a asParser , $a asParser , s0.	s0 def: s1 / nil asParser.	parser := s0 flatten.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'aaaa' to: 'aaaa'.	self assert: parser parse: 'aaaaaa' to: 'aaaaaa'.	self assert: parser parse: 'a' to: '' end: 0.	self assert: parser parse: 'aaa' to: 'aa' end: 2.	self assert: parser parse: 'aaaaa' to: 'aaaa' end: 4.	self assert: parser parse: 'aaaaaaa' to: 'aaaaaa' end: 6</body>

<body package="PetitTests">testParseAbAbAb	"S ::= (A B)+"		| parser |	parser := ($a asParser , $b asParser) plus flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'abab' to: 'abab'.	self assert: parser parse: 'ababab' to: 'ababab'.	self assert: parser parse: 'abababab' to: 'abababab'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'ababa' to: 'abab' end: 4.	self assert: parser parse: 'abababb' to: 'ababab' end: 6.	self assert: parser parse: 'ababababa' to: 'abababab' end: 8.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'bab'</body>

<body package="PetitTests">testParseAbabbb	"S ::= (A | B)+"	| parser |	parser := ($a asParser / $b asParser) plus flatten.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'b' to: 'b'.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'ba' to: 'ba'.	self assert: parser parse: 'aaa' to: 'aaa'.	self assert: parser parse: 'aab' to: 'aab'.	self assert: parser parse: 'aba' to: 'aba'.	self assert: parser parse: 'baa' to: 'baa'.	self assert: parser parse: 'abb' to: 'abb'.	self assert: parser parse: 'bab' to: 'bab'.	self assert: parser parse: 'bba' to: 'bba'.	self assert: parser parse: 'bbb' to: 'bbb'.	self assert: parser parse: 'ac' to: 'a' end: 1.	self assert: parser parse: 'bc' to: 'b' end: 1.	self assert: parser parse: 'abc' to: 'ab' end: 2.	self assert: parser parse: 'bac' to: 'ba' end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body>

<body package="PetitTests">testParseAnBnCn	"PEGs for a non context- free language: 				a^n , b^n , c^n			S &lt;- &amp;P1 P2 	P1 &lt;- AB 'c' 	AB &lt;- 'a' AB 'b' / epsilon	P2 &lt;- 'a'* BC end	BC &lt;- 'b' BC 'c' / epsilon"		| s p1 ab p2 bc |	s := PPUnresolvedParser new.	p1 := PPUnresolvedParser new.	ab := PPUnresolvedParser new.	p2 := PPUnresolvedParser new.	bc := PPUnresolvedParser new.		s def: (p1 and , p2 end) flatten.	p1 def: ab , $c asParser.	ab def: ($a asParser , ab , $b asParser) optional.	p2 def: $a asParser star , bc.	bc def: ($b asParser , bc , $c asParser) optional.		self assert: s parse: 'abc' to: 'abc'.	self assert: s parse: 'aabbcc' to: 'aabbcc'.	self assert: s parse: 'aaabbbccc' to: 'aaabbbccc'.	self assert: s fail: 'bc'.	self assert: s fail: 'ac'.	self assert: s fail: 'ab'.	self assert: s fail: 'abbcc'.	self assert: s fail: 'aabcc'.	self assert: s fail: 'aabbc'</body>
</methods>

<methods>
<class-id>PetitParser.PPComposedTest</class-id> <category>accessing</category>

<body package="PetitTests">comment	^ ($" asParser , $" asParser negate star , $" asParser) flatten</body>

<body package="PetitTests">identifier	^ (#letter asParser , #word asParser star) flatten</body>

<body package="PetitTests">number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten</body>
</methods>

<methods>
<class-id>PetitParser.PPParserTest</class-id> <category>testing-properties</category>

<body package="PetitTests">testHasProperty	| parser |	parser := PPParser new.	self deny: (parser hasProperty: #foo).	parser propertyAt: #foo put: 123.	self assert: (parser hasProperty: #foo)</body>

<body package="PetitTests">testPostCopy	| parser copy |	parser := PPParser new.	parser propertyAt: #foo put: true.	copy := parser copy.	copy propertyAt: #foo put: false.	self assert: (parser propertyAt: #foo).	self deny: (copy propertyAt: #foo)</body>

<body package="PetitTests">testPropertyAt	| parser |	parser := PPParser new.	self should: [ parser propertyAt: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo)</body>

<body package="PetitTests">testPropertyAtIfAbsent	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo ifAbsent: [ false ])</body>

<body package="PetitTests">testPropertyAtIfAbsentPut	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsentPut: [ true ]).	self assert: (parser propertyAt: #foo ifAbsentPut: [ false ])</body>

<body package="PetitTests">testRemoveProperty	| parser |	parser := PPParser new.	self should: [ parser removeProperty: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo)</body>

<body package="PetitTests">testRemovePropertyIfAbsent	| parser |	parser := PPParser new.	self assert: (parser removeProperty: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo ifAbsent: [ false ])</body>
</methods>

<methods>
<class-id>PetitParser.PPParserTest</class-id> <category>testing</category>

<body package="PetitTests">testAction	| block parser |	block := [ :char | char asUppercase ].	parser := #any asParser ==&gt; block.	self assert: parser block = block.	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B</body>

<body package="PetitTests">testAnd	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten and.		self assert: parser parse: 'foobar' to: #('foo' 'bar') end: 3.	self assert: parser fail: 'foobaz'.		parser := 'foo' asParser and.	self assert: parser and = parser</body>

<body package="PetitTests">testAnswer	| parser |	parser := $a asParser answer: $b.		self assert: parser parse: 'a' to: $b.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testBlock	| parser |	parser := [ :s | s next ] asParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil</body>

<body package="PetitTests">testChoice	| parser |	parser := $a asParser / $b asParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'</body>

<body package="PetitTests">testDelimitedBy	| parser |	parser := $a asParser delimitedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'</body>

<body package="PetitTests">testEndOfInput	| parser |	parser := PPEndOfInputParser on: $a asParser.	self assert: parser end = parser.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa'</body>

<body package="PetitTests">testEndOfInputAfterMatch	| parser |	parser := 'stuff' asParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff'.	self assert: parser fail: 'fluff'</body>

<body package="PetitTests">testEpsilon	| parser |	parser := nil asParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0</body>

<body package="PetitTests">testFailing	| parser result |	parser := PPFailingParser message: 'Plonk'.	self assert: parser message = 'Plonk'.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.		result := parser parse: 'a'.	self assert: result message = 'Plonk'.	self assert: result printString = 'Plonk at 0'</body>

<body package="PetitTests">testFlatten	| parser |	parser := $a asParser flatten.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: #($a) to: #($a).		self assert: parser fail: ''.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testLiteralObject	| parser |	parser := PPLiteralObjectParser 		on: $a		message: 'letter "a" expected'.	self assert: parser literal = $a.	self assert: parser message = 'letter "a" expected'.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testLiteralObjectCaseInsensitive	| parser |	parser := $a asParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'</body>

<body package="PetitTests">testLiteralSequence	| parser |	parser := PPLiteralSequenceParser 		on: 'abc'		message: 'sequence "abc" expected'.	self assert: parser size = 3.	self assert: parser literal = 'abc'.	self assert: parser message = 'sequence "abc" expected'.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'</body>

<body package="PetitTests">testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'</body>

<body package="PetitTests">testMax	| parser |	parser := $a asParser max: 2.	self assert: parser min = 0.	self assert: parser max = 2.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2.	self assert: parser parse: 'aaaa' to: #($a $a) end: 2.		self assert: (parser printString endsWith: '[0, 2]')</body>

<body package="PetitTests">testMemoized	| count parser twice |	count := 0.	parser := [ :s | count := count + 1. s next ] asParser memoized.	twice := parser and , parser.		count := 0.	self assert: parser parse: 'a' to: $a.	self assert: count = 1.	count := 0.	self assert: twice parse: 'a' to: #($a $a).	self assert: count = 1.		self assert: parser memoized = parser</body>

<body package="PetitTests">testMin	| parser |	parser := $a asParser min: 2.	self assert: parser min = 2.	self assert: parser max &gt; parser min.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).		self assert: (parser printString endsWith: '[2, *]')</body>

<body package="PetitTests">testMinMax	| parser |	parser := $a asParser min: 2 max: 4.	self assert: parser min = 2.	self assert: parser max = 4.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	self assert: parser parse: 'aaaaa' to: #($a $a $a $a) end: 4.	self assert: parser parse: 'aaaaaa' to: #($a $a $a $a) end: 4.		self assert: (parser printString endsWith: '[2, 4]')</body>

<body package="PetitTests">testNegate	| parser |	parser := 'foo' asParser negate.		self assert: parser parse: 'f' to: $f end: 1.	self assert: parser parse: 'fo' to: $f end: 1.	self assert: parser parse: 'fob' to: $f end: 1.	self assert: parser parse: 'ffoo' to: $f end: 1.		self assert: parser fail: ''.	self assert: parser fail: 'foo'</body>

<body package="PetitTests">testNot	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar'</body>

<body package="PetitTests">testOptional	| parser |	parser := $a asParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0</body>

<body package="PetitTests">testPermutation	| parser |	parser := #any asParser , #any asParser , #any asParser.	self assert: (parser permutation: #()) parse: '123' to: #().	self assert: (parser permutation: #(1)) parse: '123' to: #($1).	self assert: (parser permutation: #(1 3)) parse: '123' to: #($1 $3).	self assert: (parser permutation: #(3 1)) parse: '123' to: #($3 $1).	self assert: (parser permutation: #(2 2)) parse: '123' to: #($2 $2).	self assert: (parser permutation: #(3 2 1)) parse: '123' to: #($3 $2 $1).		self should: [ parser permutation: #(0) ] raise: Error.	self should: [ parser permutation: #(4) ] raise: Error.	self should: [ parser permutation: #($2) ] raise: Error</body>

<body package="PetitTests">testPluggable	| block parser |	block := [ :stream | stream position ].	parser := block asParser.	self assert: parser block = block</body>

<body package="PetitTests">testPlus	| parser |	parser := $a asParser plus.	self assert: parser min = 1.	self assert: parser max &gt; parser min.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'</body>

<body package="PetitTests">testPlusGreedy	| parser |	parser := #word asParser plusGreedy: #digit asParser.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.</body>

<body package="PetitTests">testPlusLazy	| parser |	parser := #word asParser plusLazy: #digit asParser.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3</body>

<body package="PetitTests">testSeparatedBy	| parser |	parser := $a asParser separatedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body>

<body package="PetitTests">testSequence	| parser |	parser := $a asParser , $b asParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	self assert: parser fail: 'ba'.	self assert: parser fail: 'bab'</body>

<body package="PetitTests">testStar	| parser |	parser := $a asParser star.	self assert: parser min = 0.	self assert: parser max &gt; parser min.		self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).		self assert: parser parse: 'b' to: #() end: 0.	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3</body>

<body package="PetitTests">testStarGreedy	| parser |	parser := #word asParser starGreedy: #digit asParser.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5</body>

<body package="PetitTests">testStarLazy	| parser |	parser := #word asParser starLazy: #digit asParser.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3</body>

<body package="PetitTests">testTimes	| parser |	parser := $a asParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2</body>

<body package="PetitTests">testToken	| parser |	parser := $a asParser token.	self assert: parser tokenClass = PPToken.	self assert: parser parse: 'a' toToken: 1 stop: 1.		self assert: parser fail: 'b'.	self assert: parser fail: ''.		parser := $a asParser token: PPToken.	self assert: parser tokenClass = PPToken.	self assert: parser parse: 'a' toToken: 1 stop: 1.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testTrim	| parser |	parser := $a asParser token trim.	self assert: parser trim = parser.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testTrimBlanks	| parser |	parser := $a asParser token trimBlanks.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.</body>

<body package="PetitTests">testTrimSpaces	| parser |	parser := $a asParser token trimSpaces.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body>

<body package="PetitTests">testUnresolved	| parser |	parser := PPUnresolvedParser new.		self assert: parser isUnresolved.	self should: [ parser parse: '' ] raise: Error.	self should: [ parser parse: 'a' ] raise: Error.	self should: [ parser parse: 'ab' ] raise: Error.		parser := nil asParser.	self deny: parser isUnresolved</body>

<body package="PetitTests">testWrapped	| parser |	parser := $a asParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.		parser := (($a asParser , $b asParser ) wrapped , $c asParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)</body>

<body package="PetitTests">testWrapping	| parser result |	parser := #digit asParser plus &gt;=&gt; [ :stream :cc | 		Array 			with: stream position 			with: cc value 			with: stream position ].	self assert: parser parse: '1' to: #(0 ($1) 1).	self assert: parser parse: '12' to: #(0 ($1 $2) 2).	self assert: parser parse: '123' to: #(0 ($1 $2 $3) 3).		result := parser parse: 'a'.	self assert: result first = 0.	self assert: result petitSecond isPetitFailure.	self assert: result last = 0</body>

<body package="PetitTests">testXor	| parser |	parser := ($a asParser / $b asParser)			|  ($b asParser / $c asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'.		" truly symmetric "	parser := ($b asParser / $c asParser)			|  ($a asParser / $b asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'</body>
</methods>

<methods>
<class-id>PetitParser.PPParserTest</class-id> <category>testing-utilities</category>

<body package="PetitTests">testChildren	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==&gt; #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 children isEmpty.	self assert: p2 children size = 1.	self assert: p3 children size = 2</body>

<body package="PetitTests">testFailure	| failure |	failure := PPFailure message: 'Error' at: 3.		self assert: failure message = 'Error'.	self assert: failure position = 3.	self assert: failure isPetitFailure.	self deny: 4 isPetitFailure.	self deny: 'foo' isPetitFailure</body>

<body package="PetitTests">testListConstructor	| p1 p2 p3 |	p1 := PPChoiceParser with: $a asParser.	p2 := PPChoiceParser with: $a asParser with: $b asParser.	p3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).		self assert: p1 children size = 1.	self assert: p2 children size = 2.	self assert: p3 children size = 3</body>

<body package="PetitTests">testMatches	| parser |	parser := $a asParser.		self assert: (parser matches: 'a').	self deny: (parser matches: 'b').		self assert: (parser matches: 'a' readStream).	self deny: (parser matches: 'b' readStream)</body>

<body package="PetitTests">testMatchesIn	| parser result |	parser := $a asParser.		result := parser matchesIn: 'abba'.	self assert: result size = 2.	self assert: result first = $a.	self assert: result last = $a.		result := parser matchesIn: 'baaah'.	self assert: result size = 3.	self assert: result first = $a.	self assert: result last = $a</body>

<body package="PetitTests">testMatchesInEmpty	"Empty matches should properly advance and match at each position and at the end."	| parser result |	parser := [ :stream | stream position ] asParser.		result := parser matchesIn: '123'.	self assert: result asArray = #(0 1 2 3)</body>

<body package="PetitTests">testMatchesInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.		result := parser matchesIn: 'a123b'.	self assert: result size = 2.	self assert: result first = #($1 $2).	self assert: result last = #($2 $3)</body>

<body package="PetitTests">testMatchingRangesIn	| input parser result |	input := 'a12b1'.	parser := #digit asParser plus.	result := parser matchingRangesIn: input.	self assert: result size = 3.	result do: [ :each | self assert: (parser matches: (input copyFrom: each first to: each last)) ]</body>

<body package="PetitTests">testParse	| parser result |	parser := $a asParser.		self assert: (parser parse: 'a') = $a.	self assert: (result := parser parse: 'b') isPetitFailure.	self assert: (result message petitIncludesSubString: '$a').	self assert: (result message petitIncludesSubString: 'expected').	self assert: (result position = 0).		self assert: (parser parse: 'a' readStream) = $a.	self assert: (result := parser parse: 'b' readStream) isPetitFailure.	self assert: (result message petitIncludesSubString: '$a').	self assert: (result message petitIncludesSubString: 'expected').	self assert: (result position = 0)</body>

<body package="PetitTests">testParseOnError0	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.	result := parser parse: 'b' onError: [ seen := true ].	self assert: result.	self assert: seen</body>

<body package="PetitTests">testParseOnError1	| parser result seen |	parser := $a asParser.		result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.		result := parser parse: 'b' onError: [ :failure | 		self assert: (failure position = 0).		self assert: (failure message petitIncludesSubString: '$a').		self assert: (failure message petitIncludesSubString: 'expected').		seen := true ].	self assert: result.	self assert: seen</body>

<body package="PetitTests">testParseOnError2	| parser result seen |	parser := $a asParser.		result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.	result := parser parse: 'b' onError: [ :msg :pos | 		self assert: (msg petitIncludesSubString: '$a').		self assert: (msg petitIncludesSubString: 'expected').		self assert: pos = 0.		seen := true ].	self assert: result.	self assert: seen</body>

<body package="PetitTests">testParser	| parser |	parser := PPParser new.		self assert: parser isPetitParser.	self deny: 4 isPetitParser.	self deny: 'foo' isPetitParser</body>
</methods>

<methods>
<class-id>PetitParser.PPParserTest</class-id> <category>testing-accessing</category>

<body package="PetitTests">testNamed	| parser |	parser := PPSequenceParser new.	self assert: parser name isNil.		parser := PPChoiceParser named: 'choice'.	self assert: parser name = 'choice'.		parser := $* asParser name: 'star'.	self assert: parser name = 'star'</body>

<body package="PetitTests">testPrint	| parser |	parser := PPParser new.	self assert: (parser printString petitIncludesSubString: 'PPParser').		parser := PPParser named: 'choice'.	self assert: (parser printString petitIncludesSubString: 'PPParser(choice').		parser := PPLiteralObjectParser on: $a.	self assert: (parser printString petitIncludesSubString: '$a').		parser := PPFailingParser message: 'error'.	self assert: (parser printString petitIncludesSubString: 'error').		parser := PPPredicateObjectParser on: [ :c | true ] message: 'error'.	self assert: (parser printString petitIncludesSubString: 'error')</body>
</methods>

<methods>
<class-id>PetitParser.PPParserTest</class-id> <category>testing-fixtures</category>

<body package="PetitTests">testSideEffectChoice	"Adding another element to a choice should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 / $b asParser.	p3 := p1 / $c asParser.		self assert: p1 parse: 'a'.	self assert: p1 fail: 'b'.	self assert: p1 fail: 'c'.		self assert: p2 parse: 'a'.	self assert: p2 parse: 'b'.	self assert: p2 fail: 'c'.		self assert: p3 parse: 'a'.	self assert: p3 fail: 'b'.	self assert: p3 parse: 'c'</body>

<body package="PetitTests">testSideEffectListCopy	| old new |	old := $a asParser , $b asParser.	new := old copy.		self deny: old == new.	self deny: old children == new children.	self assert: old children first == new children first.	self assert: old children last == new children last</body>

<body package="PetitTests">testSideEffectSequence	"Adding another element to a sequence should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 , $b asParser.	p3 := p1 , $c asParser.		self assert: p1 parse: 'a'.		self assert: p1 parse: 'ab' end: 1.	self assert: p1 parse: 'ac' end: 1.		self assert: p2 fail: 'a'.		self assert: p2 parse: 'ab'.	self assert: p2 fail: 'ac'.	self assert: p3 fail: 'a'.		self assert: p3 fail: 'ab'.	self assert: p3 parse: 'ac'</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateTest</class-id> <category>testing</category>

<body package="PetitTests">testOnMessage	| block parser |	block := [ :char | char = $* ].	parser := PPPredicateObjectParser on: block message: 'starlet'.	self assert: parser block = block.	self assert: parser message = 'starlet'.		self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateTest</class-id> <category>private</category>

<body package="PetitTests">charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateTest</class-id> <category>testing-objects</category>

<body package="PetitTests">testAny	| parser |	parser := #any asParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''</body>

<body package="PetitTests">testAnyExceptAnyOf	| parser |	parser := PPPredicateObjectParser anyExceptAnyOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','</body>

<body package="PetitTests">testAnyOf	| parser |	parser := PPPredicateObjectParser anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'</body>

<body package="PetitTests">testBetweenAnd	| parser |	parser := PPPredicateObjectParser between: $b and: $d.	self assertCharacterSets: parser.	self assert: parser fail: 'a'.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser parse: 'd' to: $d.	self assert: parser fail: 'e'</body>

<body package="PetitTests">testExpect	| parser |	parser := PPPredicateObjectParser expect: $a.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateTest</class-id> <category>utilities</category>

<body package="PetitTests">assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]</body>

<body package="PetitTests">parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (String with: char))			ifTrue: [ result nextPut: char ] ].	^ result contents</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateTest</class-id> <category>testing-sequence</category>

<body package="PetitTests">testSequenceParser	| parser |	parser := PPPredicateSequenceParser 		on: [ :value | value first isUppercase ] 		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size = 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.		parser := parser negate.	self assert: parser size = 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'</body>
</methods>

<methods>
<class-id>PetitParser.PPPredicateTest</class-id> <category>testing-chars</category>

<body package="PetitTests">testBlank	| parser |	parser := #blank asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)</body>

<body package="PetitTests">testChar	| parser |	parser := $* asParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'</body>

<body package="PetitTests">testCr	| parser |	parser := #cr asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr</body>

<body package="PetitTests">testDigit	| parser |	parser := #digit asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'</body>

<body package="PetitTests">testHex	| parser |	parser := #hex asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'</body>

<body package="PetitTests">testLetter	| parser |	parser := #letter asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'</body>

<body package="PetitTests">testLf	| parser |	parser := #lf asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character lf) to: Character lf</body>

<body package="PetitTests">testLowercase	| parser |	parser := #lowercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.	self assert: parser fail: 'A'.	self assert: parser fail: '0'</body>

<body package="PetitTests">testNewline	| parser |	parser := #newline asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr.	self assert: parser parse: (String with: Character lf) to: Character lf.	self assert: parser fail: ' '</body>

<body package="PetitTests">testPunctuation	| parser |	parser := #punctuation asParser.	self assertCharacterSets: parser.	self assert: parser parse: '.' to: $..	self assert: parser parse: ',' to: $,.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '1'</body>

<body package="PetitTests">testSpace	| parser |	parser := #space asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'</body>

<body package="PetitTests">testTab	| parser |	parser := #tab asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab</body>

<body package="PetitTests">testUppercase	| parser |	parser := #uppercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '0'</body>

<body package="PetitTests">testWord	| parser |	parser := #word asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'</body>
</methods>

<do-it>"Imported Classes:"</do-it>

<do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it>

<class>
<name>TestCase</name>
<environment>SUnit</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars>testSelector </inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>SUnit</category>
<attributes>
<package>SUnitToo</package>
</attributes>
</class>

<class>
<name>PPCompositeParser</name>
<environment>PetitParser</environment>
<super>PetitParser.PPDelegateParser</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>PetitParser-Tools</category>
<attributes>
<package>PetitParser</package>
</attributes>
</class>

<class>
<name>CharacterArray</name>
<environment>Core</environment>
<super>Core.ArrayedCollection</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars></class-inst-vars>
<imports></imports>
<category>Collections-Text</category>
<attributes>
<package>Collections-Text</package>
</attributes>
</class>

<class>
<name>TestResource</name>
<environment>SUnit</environment>
<super>Core.Object</super>
<private>false</private>
<indexed-type>none</indexed-type>
<inst-vars></inst-vars>
<class-inst-vars>current </class-inst-vars>
<imports></imports>
<category>SUnit</category>
<attributes>
<package>SUnitToo</package>
</attributes>
</class>

</st-source>
